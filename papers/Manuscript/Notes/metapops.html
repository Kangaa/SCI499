<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.302">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Metapops</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="metapops_files/libs/clipboard/clipboard.min.js"></script>
<script src="metapops_files/libs/quarto-html/quarto.js"></script>
<script src="metapops_files/libs/quarto-html/popper.min.js"></script>
<script src="metapops_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="metapops_files/libs/quarto-html/anchor.min.js"></script>
<link href="metapops_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="metapops_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="metapops_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="metapops_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="metapops_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Metapops</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="heterogeneous-mixing" class="level2">
<h2 class="anchored" data-anchor-id="heterogeneous-mixing">Heterogeneous Mixing</h2>
<p>A fundamental assumption of the simple compartmental model presented in <strong>?@sec-Compartmental_models</strong> is homogeneous mixing, wherein each susceptible individual is considered equally likely to come in contact with an infectious individual, and themselves become infected. However, real-world populations are not uniform in their interactions (particularly on a scale like that of <strong>?@sec-Melb_SIR</strong>), leading to the need for more realistic models that account for heterogeneous mixing patterns. In this section, we explore models that relax the assumption of homogenous mixing.</p>
<p>Extending Compartmental Models</p>
<p>Multi-Patch, ‘Subdivided’ Models</p>
<p>The concept of multi-patch or subdivided models is a cornerstone in metapopulation modeling. Pioneering work by researchers such as Wilson <span class="citation" data-cites="wilson1945">[@wilson1945]</span> and Haskey <span class="citation" data-cites="haskey1957">[@haskey1957]</span> laid the foundation for these models. Within multi-patch models, each patch represents a distinct subpopulation, and interactions within a patch are assumed to be random, while interactions between patches are limited. Key Assumptions in Multi-Patch Models</p>
<p>Metapopulation models, including multi-patch models, often rely on certain assumptions to simplify the mathematical framework while retaining essential epidemiological insights. These assumptions typically include:</p>
<pre><code>Constant Size: The population size within each patch remains constant over time, implying equal birth and death rates.

Constant Recovery Parameter ($\gamma$): The rate of recovery from infection ($\gamma$) is assumed to be consistent across all patches.

No Permanent Movement of Individuals Between Patches: Individuals do not permanently migrate between patches.

Disease Spread on Contact: Disease transmission occurs through contact between susceptible and infective individuals. The total number of new cases is typically modeled as a proportion, $\beta$, of the number of contacts.

Proportionate Mixing: Proportionate mixing, as proposed by Sattenspiel [@sattenspiel1988], implies that the number of encounters is proportional to the size of the subpopulations involved. The mixing matrices used in these models are chosen to fit known patterns of incidence, often based on empirical data, rather than theoretical grounds. The importance of variation in mixing patterns for infection transmission is often explored within this framework.</code></pre>
<p>Mixing Matrix</p>
<p>Metapopulation models heavily rely on mixing matrices to describe the dynamics of disease transmission within and between patches. Two key types of matrices are commonly used:</p>
<pre><code>Migration Matrix (Bodmer [@bodmer1968]): This matrix represents backward stochastic migration probabilities, where the elements m, j give the probabilities that the parents of individuals in population i came from population j.

Mixing (Contact) Matrix (Sattenspiel [@sattenspiel1987]): This matrix characterizes the probability of two individuals from different neighborhoods coming into contact. Unlike the migration matrix, the mixing matrix is a forward stochastic migration matrix, with each element m, representing the probability that an individual from population i moves to population j [@sattenspiel1988].</code></pre>
<p>In summary, metapopulation models offer a powerful framework for capturing the complexities of disease transmission in heterogeneous populations. These models rely on assumptions that simplify real-world interactions, while mixing matrices provide a means to quantify the interactions within and between subpopulations. Through these models, we can gain valuable insights into the spread of infectious diseases in diverse and interconnected communities.</p>
</section>
<section id="formulation" class="level2">
<h2 class="anchored" data-anchor-id="formulation">Formulation</h2>
<p>Let us more formally specify our SIR metapopulation.</p>
<p>As in the simple SIR from <span class="citation" data-cites="sec_SIR">@sec_SIR</span> there are three main compartments representing the disease status of individuals of all individuals in the population</p>
<p><span class="math display">\[
S + I + R = N
\]</span></p>
<p>However, each compartment is completely partitioned into a number, <span class="math inline">\(n\)</span>, of separate patches <span class="math inline">\(i\)</span> for <span class="math inline">\(i \in \{ 1 \ldots, n\}\)</span>.</p>
<p><span class="math display">\[
\sum\limits_{i}^{n} S_{i} = S
\]</span></p>
<p><span class="math display">\[
\sum\limits_{i}^{n} I_{i} = I
\]</span></p>
<p><span class="math display">\[
\sum\limits_{i}^{n} R_{i} = R
\]</span></p>
<p><span class="math display">\[
S_{i} + I_i + R_i = N_i
\]</span></p>
<ul>
<li><p>There is only one <span class="math inline">\(n\)</span>, meaning each compartment has equal number of patches.</p>
<h2 id="mixing" class="anchored">Mixing</h2></li>
<li><p><span class="math inline">\(m_{ij}\)</span> represents the probability that a susceptible individual from in patch <span class="math inline">\(i\)</span> comes into contact with an infective individual from patch <span class="math inline">\(j\)</span>.</p>
<ul>
<li><span class="math inline">\(0 \leq m_{ij} \leq 1\)</span> and <span class="math inline">\(\sum_j m_{ij} =1\)</span></li>
</ul></li>
<li><p>We can summarise all <span class="math inline">\(m_{ij}\)</span> in a <span class="math inline">\(n \times n\)</span> matrix <span class="math inline">\(M\)</span>, which we call the ‘mixing matrix’</p>
<ul>
<li>M is a stochastic matrix</li>
</ul>
<dl>
<dt>mixing matrix</dt>
<dd>
<p>a something something</p>
</dd>
<dt>another term</dt>
<dd>
<p>another def</p>
</dd>
</dl></li>
</ul>
<section id="force-of-infection" class="level3">
<h3 class="anchored" data-anchor-id="force-of-infection">Force of infection</h3>
<p><span class="citation" data-cites="moss2019">@moss2019</span></p>
<ul>
<li><p>FOI in region <span class="math inline">\(i\)</span> exerted by infectious individuals who reside in patch <span class="math inline">\(j\)</span> (<span class="math inline">\(\beta_{ij}\)</span>)</p>
<p><span class="math display">\[\beta_{ij} = \beta \cdot I_j \cdot M'_{j,i}\]</span></p></li>
<li><p>total FOI in patch <span class="math inline">\(i\)</span> (<span class="math inline">\(\Lambda_i\)</span>)</p>
<p><span class="math display">\[
\Lambda_i = \sum\limits_{j =1}^{r}\beta_{ij}
\]</span></p></li>
<li><p>and the FOI vector</p>
<p><span class="math display">\[
\boldsymbol{\Lambda} = \beta \cdot \boldsymbol{I} \times M'
\]</span></p></li>
</ul>
</section>
<section id="dynamics" class="level3">
<h3 class="anchored" data-anchor-id="dynamics">Dynamics</h3>
<p><span class="math display">\[
\begin{aligned}
\frac{d S_i}{d t} &amp; =-\Lambda_i \cdot \frac{S_i}{N_i} \\
\frac{d E_i}{d t} &amp; =\Lambda_i \cdot \frac{S_i}{N_i}-\sigma E_I \\
\frac{d I_i}{d t} &amp; =\sigma E_I-\gamma I_i \\
\frac{d R_i}{d t} &amp; =\gamma I_i
\end{aligned}
\]</span></p>
<p><span class="citation" data-cites="jacquez1988">@jacquez1988</span></p>
</section>
</section>
<section id="implimentation" class="level2">
<h2 class="anchored" data-anchor-id="implimentation">Implimentation</h2>
<ul>
<li><p>We impliment the metapopulation model as a CTMC in an analogous way to <strong>?@sec-SIR_CTMC</strong>, but with a few key differences</p></li>
<li><p>Following <span class="citation" data-cites="moss2019">@moss2019</span></p></li>
</ul>
<section id="patches" class="level3">
<h3 class="anchored" data-anchor-id="patches">Patches</h3>
<pre><code>-   The GMGCCSA is partitioned into 40 subpopulations, based on the @2023AustralianStatisticalGeographya SA3 classification system.

-   The population of each patch is given in appendix_n and shown in @figGMelbSA3Pop</code></pre>
</section>
<section id="initial-conditions" class="level3">
<h3 class="anchored" data-anchor-id="initial-conditions">Initial conditions</h3>
<ul>
<li><p>At the beginning of a simulation, all patches are composed of entirely susceptivle individuals.</p></li>
<li><p>a number, <span class="math inline">\(I_0\)</span>, of individuals in a randomly selected patch, <span class="math inline">\(\alpha\)</span>, become infected.</p></li>
<li><p>i.e</p></li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\alpha &amp; \sim \mathcal{U}\{1, r\} \\
S_i(0) &amp; = \begin{cases}N_i &amp; \text { if } i \neq \alpha \\
N_i-E_0 &amp; \text { if } i=\alpha\end{cases} \\
E_i(0) &amp; = \begin{cases}0 &amp; \text { if } i \neq \alpha \\
E_0 &amp; \text { if } i=\alpha\end{cases} \\
R_i(0)=0
\end{aligned}
\]</span></p>
</section>
<section id="mixing-1" class="level3">
<h3 class="anchored" data-anchor-id="mixing-1">Mixing</h3>
<ul>
<li><p>The mixing matrix was defined after <span class="citation" data-cites="moss2019">@moss2019</span></p></li>
<li><p>Empirically informed Origin Destination (OD) matrix</p>
<ul>
<li><p>Derived from the 2016 Census data</p>
<ul>
<li><p>usual residence X place of work matrix</p></li>
<li><p>Determines contact <em>between regions</em> but not <em>within</em> the region of residence</p></li>
</ul></li>
<li><p><span class="math display">\[
F=\left(\begin{array}{cccc}f_{1,1} &amp; f_{1,2} &amp; \cdots &amp; f_{1, r} \\f_{2,1} &amp; f_{2,2} &amp; \cdots &amp; f_{2, r} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\f_{r, 1} &amp; f_{r, 2} &amp; \cdots &amp; f_{r, r}\end{array}\right)
\]</span></p></li>
<li><p><span class="math display">\[
\begin{aligned}
f_{i, i} &amp; =0 \\
\sum_{j=1}^{r} f_{i, j} &amp; =1 \quad \forall i \in[1 . . r]
\end{aligned}\]</span></p></li>
</ul></li>
<li><p>Within patch mixing is given by a parameter <span class="math inline">\(\delta^H_i\)</span>, the remaining mixing proportion, <span class="math inline">\(\delta^*_r = 1-\delta^H_i\)</span> is distributed among the non-local patches <span class="math display">\[
M=\left(\begin{array}{cccc}
\delta_{1}^{H} &amp; \delta_{1}^{*} f_{1,2} &amp; \cdots &amp; \delta_{1}^{*} f_{1, r} \\
\delta_{2}^{*} f_{2,1} &amp; \delta_{2}^{H} &amp; \cdots &amp; \delta_{2}^{*} f_{2, r} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\delta_{r}^{*} f_{r, 1} &amp; \delta_{r}^{*} f_{r, 2} &amp; \cdots &amp; \delta_{r}^{H}
\end{array}\right)
\]</span></p></li>
</ul>
</section>
<section id="simulation" class="level3">
<h3 class="anchored" data-anchor-id="simulation">Simulation</h3>
<ul>
<li><p>As per <strong>?@sec-SIR_sim</strong></p></li>
<li><p>detlta t will be the sum of exponentially distributed times (expt(sum.rates))</p></li>
<li><p>State change will involve event type (as in single patch), and event location</p>
<ul>
<li>State change vector is now 2*n patch long</li>
</ul></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>