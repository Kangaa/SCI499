---
title: "Hierarchical mixing"
format:
 pdf: 
  keep-tex: true
execute:
  eval: false
  echo: false
  message: false
  warning: false
---

```{r, eval=TRUE, packages}
library(tidyverse)
library(sf)
library(glue)
library(RColorBrewer)
```

In @sec-MossGmelb, we observed the construction of a meta-population mixing matrix from empirical origin-destination (OD) data. The patches used in the example were based on the 'SA3' regions of the Australian Statistical Geography Standard's Statistical Areas (SA) classification [@2023AustralianStatisticalGeographya] (comprising 40 patches for the Greater Melbourne area in that example). In this chapter we will use the larger ASGS SA classification structure to create multiple meta population models of the same geographical area at different spatial resolutions.

## Hierarchical Structure of the SA classification

An important feature of the SA classification structure is that there are multiples scales of classification organised such that lower level SAs are nested within higher level SAs. These levels are denoted by the numbers 1-5, with special groupings for capital city areas @fig-ASGS. For example, several SA3 regions can reside within a single SA4 region, and multiple SA4 regions are contained within the Greater Melbourne Capital City SA (GMCCSA). Moreover, each SA3 region is partitioned into a number of SA2 scale regions, which in turn are partitioned further into a number of SA1 scale regions. @fig-GMelbSA2SA3SA4 shows the borders of the 361 SA2, 40 SA3, and 9 SA4 regions of the GMCCSA.

![Structure of The Australian Statistical Geography Standard (ASGS) Statistical Areas (SA) Classification](figures/ASGS_Diagram_2021.png){#fig-ASGS fig-align="center" width="400"}

For a specific example, the `Maribyrnong` SA3 region sits inside the `West Melbourne`SA4 region alongside `Essendon` SA3 @fig-FootscraySAexample. Both `West Melbourne` and the neighbouring `Inner Melbourne` SA4 (containing the city center and other SA3 regions), are part of the GSCCSA. Moreover, within `Marybirnong` SA3 there are six SA2 level regions (`Braybrook`, `Footscray`, `Maribyrnong`, `Seddon - Kingsville`, `West Footscray - Tottenham`, `Yarraville`), which can likewise be partitioned in to smaller SA1 level and 'Mesh Block' level regions @fig-ASGS. In @fig-FootscraySAexample, we highlight the SA1-SA4 level regions containing the main Footscray CBD (SA1 code '21303134811'; see @fig-FootscraySA1Code).

:::

```{r, eval=TRUE}

levels <- list(MB = "MB", SA1 = "SA1", SA2 = "SA2", SA3 = "SA3", SA4 = "SA4")
Shapes <- map(
  map(
    levels,
    \(x) glue("../../data/ASGS_GDA2020/{x}_2021_AUST_SHP_GDA2020/{x}_2021_AUST_GDA2020.shp")),
  read_sf)

SAcols <- brewer.pal(4, "Dark2")

GMelb_Shapes <- Shapes |>
  map(\(x) filter(x, GCC_NAME21 == "Greater Melbourne"))



#GMelb_Shapes <- GMelb_Shapes[[1]] %>% 
#  full_join(GMelb_Shapes[[2]]) %>% 
#  full_join(GMelb_Shapes[[3]]) %>% 
#  st_sf(sf_column_name = "geometry")
  
```

Note that each red-bounded area represents a higher resolution ('lower' SA level) than the one that encloses it.

```{r, eval = FALSE}
#| label: fig-GMelbSA2SA3SA4
#| fig-cap: SA2, SA3 and SA4 borders of the Greater Melbourne Greater Capital City Statistical Area (GMGCCSA) and the the five SA3 blocks that make up the 'Melbourne - West' SA4 region, the six SA2 blocks that make up the Maribyrnong SA3 region, the forty SA1 regionsa that make up the 'Footscray' SA2 region, and the sixteen mesh blocks that make up the central Footscray '21303134811' SA1 region.
#| fig-subcap: 
#|   - ""
#|   - ""
#| layout-ncol: 2
ggplot() +
  geom_sf(data = GMelb_Shapes$SA2, fill = NA, color = SAcols[1] , linewidth = 0.1) +
  geom_sf(data = GMelb_Shapes$SA3, fill = NA, color = SAcols[2], linewidth = 0.3) +
  geom_sf(data = GMelb_Shapes$SA4, fill = NA, color =SAcols[3], linewidth = 0.5) +
  scale_color_manual(name = "SA level",
                     breaks = c("SA4", "SA3", "SA2"),
                     values = c("SA2" = SAcols[1], "SA3" = SAcols[2], "SA4" = SAcols[3])) +
  theme_bw()


GMelb_SA4_plot <- ggplot() +
  geom_sf(data = GMelb_Shapes$SA4, aes(fill = SA4_CODE21))

GMelb_SA4_colors <- ggplot_build(GMelb_SA4_plot) |> 
  pluck("data",1, "fill")


ggplot() +
  geom_sf(data = GMelb_Shapes$SA4,
          fill = "grey",
          show.legend = FALSE) +
  
  geom_sf(data = GMelb_Shapes$SA3 |> filter(SA4_NAME21 == "Melbourne - West"),
          fill = NA,
          linewidth = 0.1) +
  
  geom_sf(data = GMelb_Shapes$SA2 |> filter(SA3_NAME21 == "Maribyrnong"),
          fill = NA,
          linewidth = 0.1) +
  
  geom_sf(data = GMelb_Shapes$SA2 |> filter(SA3_NAME21 == "Maribyrnong"),
          fill = NA,
          linewidth = 0.1) +
 
  geom_sf(data = GMelb_Shapes$SA1 |> filter(SA2_NAME21 == "Footscray"),
          fill = NA,
          linewidth = 0.001) +
  geom_sf(data = GMelb_Shapes$MB |> filter(SA1_CODE21 == "21303134811"),
          fill = NA,
          linewidth = 0.001) +
  geom_sf(data = GMelb_Shapes$SA4 |> filter(SA4_NAME21 == "Melbourne - West"),
          fill = NA,
          color = SAcols[3],
          alpha = 0.5,
          linewidth = 1)+
  geom_sf(data = GMelb_Shapes$SA3 |> filter(SA3_NAME21 == "Maribyrnong"),
          fill = NA,
          color = SAcols[2],
          alpha = 0.5,
          linewidth = 1) +
  geom_sf(data = GMelb_Shapes$SA2 |> filter(SA2_NAME21 == "Footscray"),
          fill = NA,
          color = SAcols[1],
          linewidth = 1) +
   geom_sf(data = GMelb_Shapes$SA1 |>  filter(SA1_CODE21 == "21303134811"),
          fill = NA,
          color = SAcols[4],
          linewidth = 1)+
  coord_sf(xlim = c(144.8, 144.96) , ylim = c(-37.75, -37.88)) +
  theme_bw()
```

Helpfully, besides a common name Statistical Areas are also indexed by a structured code representing their classification hierarchy. For example, SA1 regions are denoted by an 11 digit code which can be decomposed into the higher level areas in which the region sits. @fig-FootscraySA1Code demonstrates this for the Footscray SA1 region considered above.

![Decomposition of theFootscray SA1 region code from @fig-FootscraySAexample into its hierachical SA components. 2 - `Victoria`; 13 - `West Melbourne`; 03 - `Maribyrnong`; 1348 - `Footscray`.](figures/FootscraySA1eg.png){#fig-FootscraySA1Code fig-align="center" width="248"}

## Comparisons between models of different scales

-   Spatial Epidemic models derived from empirical data are usually limited by the spatial resolution of their source material.

-   Comparing models at different scales has been achieved by using different model types (e.g. agent based and compartental models) to represent different scales, (Or different parameterisations(?ref)

-   We can exploit the hierarchical structure of the ASGS Statistical Areas structure by creating meta-population models representing the same overarching spatial structure), but with varying levels of resolution (e.g. by using SA2 scale patches instead of SA3 scale patches).

-   In what follows, we present metapopulation models of the GMGCSSA with patches corresponding to different levels of the SA hierarchy.

### Homogenous mixing in metapopulation models

We might initially consider the models with patch sizes 2, 3, 4 (for SA2, SA3, SA4), and construct a mixing matrix with uniform mixing across patches, i.e. $$
m_{ij} = \frac{1}{n}
$$Where $n$ is the total number of patches. While this mixing matrix would entail homogeneous mixing in a metapopulation where $N_i = N_j, \forall i,j$, we have seen in @fig-SA3Gmelb_popn, and as shown in @fig-SA2Gmelb_popn, population size is not homogenous in the GMGCCSA metapopoulations under consideration.

### Proportionate mixing {#sec-propmix}

```{r, eval = TRUE}
#| caption: Population of SA2 regions in the GMGCCSA
#| label: fig-GMelbPop


plotmixmat <- function(mixmat){
  mixmat %>%
    as_tibble(rownames = "i") %>%
    pivot_longer(-1, names_to = "j", values_to = "mixing") %>%
    ggplot() +
    aes(x = j, y = i, fill = log(mixing)) +
    geom_tile(show.legend = FALSE) +
    theme(axis.text = element_blank(),
          axis.ticks = element_blank()) +
    scale_fill_continuous(type = "viridis")}



GMelb_Popns <- map(
  map(
    c("2", "3", "4"),
    \(x) str_replace("../../data/GmelbSA_X_Pop21.csv", "_X_", x)),
  read_csv) |>
  `names<-`(c("SA2", "SA3", "SA4"))



PPMMs <- map(c("SA2", "SA3", "SA4"),
              \(x){
                size <- nrow(GMelb_Popns[[x]])

                MMpop <- matrix(NA,
                                size,
                                size,
                                dimnames = list(
                                  GMelb_Popns[[x]][[paste0(x, "_Code")]],
                                  GMelb_Popns[[x]][[paste0(x, "_Code")]]))

                Ntot = sum(GMelb_Popns[[x]][[3]])

                for (i in seq_along(MMpop[1,])){
                  for (j in seq_along(MMpop[,1])){
                    MMpop[i,j] <- GMelb_Popns[[x]][[3]][j]/Ntot
                  }
                }
                MMpop
              })
```

To correct for hetrogeneous patch populations, We can scale mixing coefficients by their patch size i.e. for two patches $i$ and $j$ the mixing coefficient $\phi_{i,j}$:

$$
\phi_{ij} = N_j/N_{tot}
$$

Which gives mixing matrices shown in @fig-GMGCC_PMM

```{r, eval=TRUE}
#| label: fig-GMelb_PPM
#| caption: Population proportional mixing matrices
#| fig-subcap: 
#|   - "SA3"
#|   - "SA4"
#| layout-ncol: 2

PPMMs[[2]] %>% 
  plotmixmat()


PPMMs[[3]] %>% 
  plotmixmat()
```

-total size -peak size -Duration of pop prop models with SA2 SA3 SA4 homogeneous patches - Expect equivalence

### Statistical Area Mixing structure {#sec-SAmixmat}

We can encode the hierarchical structure of the SA classification in hierarchical block matrices representing within and between SA region mixing. To do so, we specify a set of coefficients $\xi = [\xi_1, ..., \xi_i]$ such that $\sum\limits_{i}\xi_{i}=1$, which determine the proportion of mixing occurs at each level, $L$, of the spatial hierarchy (i.e. between SA2 regions, between SA3 regions, etc.) . This coefficient is distributed amongst patches occurring in the same level $L$ region, so mixing for any two patches, $i$ and $j$ $$
M_{ij}= \frac{\xi_{L}}{n^{L}} 
$$ {#eq-SAmix} where $$
j \in S_{i}^{L} \  \& \ j \notin S_{i}^{L-1}
$$ and $S_{i}^{L}$ is the set of patches in the same level $L$ region as $i$.

To extend the example from @sec-XX, we can consider a subset of SA2 regions from the GMGCCSA (@fig-GMelb_eg_Map, @tab-MMeg)



Docklands and West industrial are SA2 regions within the 'Melbourne City' SA3 region. Port Melbourne and Port Industrial are SA2 regions within the 'Port Melbourne' SA3 region. Footscray, Seddon-Kingsville, and Yarraville are SA2 regions within the 'Maribyrnong' SA3 region. Newport SA2 is within the Hobsons Bay SA3 region. Port Melbourne and Port Industrial are SA2 regions within the 'Port Melbourne' SA3 region. Furthermore, both 'Melbourne city' and 'Port Melbourne' are within the 'Inner Melbourne' SA4 region, while Maribyrnong and Hobsons Bay SA3 lie inside the 'West Melbourne' SA4 Region.

To model mixing between these SA2 patches (isolated from the rest of the GMGCCSA), we can construct a $8 \times 8$ mixing matrix with $\xi = \left[ \frac{1}{4}, \frac{1}{4},\frac{1}{4},\frac{1}{4} \right]$ as follows:

let $i =$ `Footscray`. Since `Footscray` is it's own SA2 region, $$M_{i,i} = \frac{1}{4}$$ When $j$ is a region in `Maribyrnong` SA3 (alongside `Footscray`), like `Yarraville` or `Seddon-Kingsville`, $M_{i,j}$ will be a proportion of $\xi_{SA3}$. $$
M_{i,j} = \frac{\xi_{SA3}}{P_{i}^{SA3} - P_{i}^{SA2}} = \frac{\frac{1}{4}}{3 - 1} = \frac{1}{8}
$$ When $j$ occurs outside the `Maribyrnong` SA3, but within the `West Melbourne` SA4, like `Newport` SA2 $$
M_{i,j} = \frac{\xi_{SA4}}{P_{i}^{SA4} - P_{i}^{SA3}} = \frac{\frac{1}{4}}{4 - 3} = \frac{1}{4}
$$ Finally when $j$ is a patch outside the `West Melbourne` SA4, like those in the `Inner Melbourne`SA4 $$
M_{i,j} = \frac{\xi_{SA5}}{P_{i}^{SA5} - P_{i}^{SA4}} = \frac{\frac{1}{4}}{8 - 4} = \frac{1}{16}
$$ thus for the row $M_{i}$, representing the mixing of individuals from Footscray, $\sum\limits_{j}M_{j}= \frac{1}{4} +\frac{1}{8} + \frac{1}{8} + \frac{1}{4} + \frac{1}{16} + \frac{1}{16} + \frac{1}{16} + \frac{1}{16} = 1$. Repeating this for all patches $i$, gives the mixing matrix represented in @fig-GMelb_eg_MixMat

```{r, eval=TRUE}
#| label: fig-GMelb_eg
#| caption:  Hierarchical Mixing matrix for the example region shown in @fig-Example_region
#| fig-subcap:
#|  - ""
#|  - ""
#| layout-ncol: 2

GMelb_MM_eg <-GMelb_Shapes$SA2 %>% 
            filter(
              SA2_NAME21 == "Port Melbourne Industrial" |
                SA2_NAME21 == "Port Melbourne" |
                SA2_NAME21 == "Docklands" |
                SA2_NAME21 == "West Melbourne - Industrial" |
                SA2_NAME21 == "Yarraville" |
                SA2_NAME21 == "Seddon - Kingsville" |
                SA2_NAME21 == "Footscray" |
                SA2_NAME21 == "Newport")
ggplot() +
  aes() +
  geom_sf(data = GMelb_MM_eg,
          fill = "grey",
          alpha = 0.3,
          col = SAcols[1],
          size = 0.5) +
  geom_sf(data = GMelb_MM_eg %>%
            group_by(SA3_CODE21) %>%
            summarise(SA3 = st_union(geometry)),
          fill = NA,
          col = SAcols[2],
          size = 1
          ) +
    geom_sf(data = GMelb_MM_eg %>%
            group_by(SA4_CODE21) %>%
            summarise(SA4 = st_union(geometry)),
          fill = NA,
          col = SAcols[3],
          size = 2
          ) +
  theme_bw()

Hmixmat <- function(data){
  levels <- data %>%
    names() %>%
    subset(grepl("SA._CODE|GCC_CODE21", .))

  xi <- rep(1/length(levels), length(levels))

  npatch = nrow(data)

  level_vec = vector("character", npatch)

  mixmat = matrix(0, npatch, npatch,
                  dimnames = list(data[[levels[1]]],
                                  data[[levels[1]]]))

  for (i in 1:npatch){
    patch_i <- data[i,]
    norm <- rep(0, length(levels))
    for (j in 1:npatch){
      patch_j <- data[j,]
      for (l in seq_along(levels)){ #find lowest level of association (LLA)
        code_l <-  levels[l]
        if (patch_i[[code_l]] == patch_j[[code_l]]){
          level_vec[j] <- levels[l] #place LLA in level_vec(i)
          norm[l:length(norm)] <- norm[l:length(norm)] + 1 #add +1 to the count of patches in the same level L as i
          break
        }
      }
    }
    for (l in seq_along(levels)){
      for (j in 1:npatch){
        if (level_vec[j] == levels[l]){
          if (l == 1) mixmat[i,j] <- xi[l]/norm[1]
          else mixmat[i,j] <- xi[l]/(norm[l] - norm[l-1])
        }
      }
    }
  }
  mixmat
}

Hmixmat(GMelb_MM_eg) %>% 
  plotmixmat()
```

Applying this process to the whole GMGCCSA yields the mixing matrices presented in figure @fig-GCC_HMM

```{r, eval=FALSE}
#| label: fig-GCC_HMM
#| cache: true
#| fig-subcap: 
#|  -""
#|  -""
#|  -""
#| layout-nrow: 2

read_csv("data/MixingMatrices/SAMM_SA2.csv") %>%
  {.[1,]} %>% 
  sum()

GMelb_Shapes[[2]] %>%
  Hmixmat %>% 
  plotmixmat

GMelb_Shapes[[3]] %>%
  Hmixmat %>% 
  plotmixmat
```

Hierarchical Mixing matrices for the Greater Melbourne Capital City Statistical Area (GMGCCSA) at three levels of spatial resolution.

### Population normalised SA mixmat

```{r }
#| label: fig-GMelb_eg_pop
#| caption:  Population proportional Hierarchical Mixing matrix for the example region shown in @fig-Example_region
#| fig-subcap:
#|  - "A"
#|  - "B"
#| layout-ncol: 2
Gmelb_pop <- 4976157

GMelb_MM_eg <-GMelb_Shapes$SA2 %>% 
            filter(
              SA2_NAME21 == "Port Melbourne Industrial" |
                SA2_NAME21 == "Port Melbourne" |
                SA2_NAME21 == "Docklands" |
                SA2_NAME21 == "West Melbourne - Industrial" |
                SA2_NAME21 == "Yarraville" |
                SA2_NAME21 == "Seddon - Kingsville" |
                SA2_NAME21 == "Footscray" |
                SA2_NAME21 == "Newport") %>% 
  tibble() %>% 
  left_join(GMelb_Popns[[1]], by = c("SA2_NAME21" = "SA2_Name")) %>% 
  st_as_sf()

GMelb_MM_eg$SA2_CODE21
```

-   in the same way as in @sec-proportionatemixing, the SA structured mixingmatrix given in @sec-SAmixmat, @eq-SAmix, will result in hetrogenous mixing due to the different population per patch @fig-gmelbpop.

-   Again, we can rectify this by scaling columns in the mixing matrix by the according population size. Due to the hierarchical structure we can reduce patch counts to population counts

$$M_{ij} = \frac{N_{j}}{N_{i}^{L} - N_{i}^{L-1}} \xi^{L}$$ if $j \in S_{i}^{L}$ & $j \notin S_{i}^{L-1}$

where $i, j$ are patches $S_{i}^{L}$ is the set of patches in level $L$ $N_i$ is the population of $i$ $N_{i}^{L}$ is the population of $S_{i}^{L}$ $\xi^{L}(\delta)$ is the proportion of mixing that occurs within $S_{i}^{L}$ but not$S_{i}^{L-1}$

```{r PMixmat}
#| label: fig-gmelbpop
#| caption:  Population of each patch in the Greater Melbourne Capital City Statistical Area (GMGCCSA) at three levels of spatial resolution.
#| fig-subcap:
#|  - fig-gmelbpop_SA1
#|  - fig-gmelbpop_SA2
#|  - fig-gmelbpop_SA3
#| layout-nrow: 2
read_csv("data/MixingMatrices/HPMM_SA2_1.0.csv") %>%
  column_to_rownames("i") %>% 
  plotmixmat()

read_csv("data/MixingMatrices/HPMM_SA3_1.0.csv") %>%
  column_to_rownames("i") %>% 
  plotmixmat()

read_csv("data/MixingMatrices/HPMM_SA4_1.0.csv") %>%
  column_to_rownames("i") %>% 
  plotmixmat()
```

### Simulation 

-   We can now simulate the spread of a disease through the GMGCCSA using the mixing matrices presented in @sec-SAmixmat and @sec-HPMM.
-   We will use the same parameters as in @sec-sim, but now we will use the population normalised mixing matrices.

```{r, eval=FALSE}


sim_dirs <- list.files("../../data/sims/", pattern = "HPMM.*none.*[1-5]1.csv", recursive = TRUE)

patch_dirs <- sim_dirs[str_detect(sim_dirs, "patchinf|patchsus")] %>%
  paste0("../../data/sims/", .)
tot_dirs <- sim_dirs[!str_detect(sim_dirs, "patchinf|patchsus")] %>%
  paste0("../../data/sims/", .)

sims <- read_csv(tot_dirs, id = "sim", col_names = c("t", "S", "I"), skip = 1)


sims <-  sims |>
  filter(t != "Int64", grepl("HPMM", sim)) %>%
  mutate(
    I = as.numeric(I),
    t = as.numeric(t),
    SA = str_extract(sim, "SA./SA(.)", 1),
    Mixmat = str_extract(sim, "SA./SA._..._..._(HPMM|HMM|OD)_", 1),
    mu = str_extract(sim, "SA./SA._..._..._.{3,4}_(.{0,3})_", 1),
    Intervention = factor(str_extract(sim,"SA./SA._..._..._.{3,4}_.{0,3}_(none|local|travel|total)", 1)),
    beta = as.numeric(str_extract(sim, "SA./SA._(...)", group = 1)),
    gamma = as.numeric(str_extract(sim, "SA./SA._..._(...)", group = 1)),
    R0 = beta/gamma,
    sim_num = str_extract(sim, "(_.{1,3}).csv", 1))
```

```{r}
sims_summary <- sims %>% 
  group_by(SA, mu, R0, sim_num) %>% 
  summarise(peaksize = max(I)/Gmelb_pop,
            finalsize = (Gmelb_pop - min(S))/Gmelb_pop,
            duration = max(t),
            peaktime = t[which(I == max(I))]) %>% 
  ungroup() %>%
  group_by(SA, mu, R0) %>%
  summarise(peaksize = mean(peaksize),
            finalsize = mean(finalsize),
            duration = mean(duration),
            peaktime = mean(peaktime))

sims_summary %>%
  ggplot() +
  aes(x = mu, y = R0, color = finalsize) +
  geom_point() +
  facet_grid(~SA)
```

```{r}
#| label: fig-SA3_OD_outcomes
#| fig-cap: Final (a) and peak (b) infection numbers (as a proportion of the entire population), peak time (c) and total duration (d) of a simulated SIR metapopulation model with OD mixing matrix at different values of $\delta^H$ and $R_0$
#| fig-subcap: 
#|   - ""
#|   - ""
#|   - ""
#|   - ""
#| layout-ncol: 2
sim_summary %>%
  filter(Intervention == "none", SA == "3", R0 <= 2) %>%
  ggplot() +
  aes(x = deltaH, y = R0) +
  geom_point(aes(col = finalsize), size = 5) +
  

sim_summary %>%
  filter(Intervention == "none", SA == "3", R0 <= 2) %>%
  ggplot() +
  aes(y = R0, x = deltaH) +
  geom_point(aes(col = peaksize), size = 5) 

sim_summary %>%
  filter(Intervention == "none", SA == "3", R0 <= 2) %>%
  ggplot() +
  aes(x = deltaH, y = R0) +
  geom_point(aes(col = log(peaktime)), size = 5) +
  scale_color_manual(breaks = 1:5, values = exp(1:5))

sim_summary %>%
  filter(Intervention == "none", SA == "3", R0 <= 2) %>%
  ggplot() +
  aes(x =deltaH, y = R0) +
  geom_point(aes(col = log(duration)), size = 5)
```
However, now we can decompose these metapopulation scale outcomes into those of the underlying subpopulation. For example, @fig-OD_patchinf_curve_eg

```{r}
SA3_Patch_dirs <- list.files("../../data/sims/SA3", pattern = "HPMM_..._none_(patchinf|patchsus)_([0-9]|[1-9][0-9]).csv", full.names = TRUE)

SA3_Patch_logs <- read_csv(SA3_Patch_dirs, id = "sim")

SA3_patch_sims <- SA3_Patch_logs %>%
  group_by(sim) %>%
  mutate(t = row_number()) %>%
  ungroup() %>%
  pivot_longer(cols = c(-sim, -t), values_to = "Count", names_to = "patch") %>%
  mutate(
    SA = str_extract(sim, "SA./SA(.)", 1),
    Mixmat = str_extract(sim, "SA./SA._..._..._(HPMM|HMM|OD)_", 1),
    mu = as.numeric(str_extract(sim, "SA./SA.*_HPMM_(...)", 1)),
    Intervention = "none",
    beta = as.numeric(str_extract(sim, "SA./SA._(...)", group = 1)),
    gamma = as.numeric(str_extract(sim, "SA./SA._..._(...)", group = 1)),
    R0 = beta/gamma,
    sim_num = str_extract(sim, "_(.{1,3}).csv", 1),
    Measure = str_extract(sim, "(inf|sus)_.{1,3}.csv", 1),
  )
```

```{r}
patch_summary <- SA3_patch_sims %>%
  group_by(patch, R0, mu, Intervention, Measure) %>%
  summarise(
    peak = max(`Count`))
```
```{r}
#| label: fig-SA3_OD_patch_peaks
#| fig-cap: showing the peak proportion of infected individuals in each SA3 patch of an OD mixing metapopulation with varying contributions of local mixing(\delta^H)
patch_summary %>%
  filter(R0 == 2.0)%>% 
  ggplot() +
  aes(x = patch, y = peak) +
  geom_point(aes(col = mu)) +
  theme(axis.text.x = element_text(angle = -45, vjust = 0, hjust = 0))
```

