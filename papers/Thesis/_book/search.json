[
  {
    "objectID": "test.html",
    "href": "test.html",
    "title": "2  Untitled",
    "section": "",
    "text": "Just a test file"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Notes",
    "section": "",
    "text": "This contains WIP notes on subjects relating to the thesis, but not in a form appropriate for publication."
  },
  {
    "objectID": "Notes/Moss.html",
    "href": "Notes/Moss.html",
    "title": "3  Replicating Moss et al. 2019",
    "section": "",
    "text": "using DrWatson\n@quickactivate \"SCI499\"\n\n#include(readdir(scriptsdir(\"MossModel\"), join = true))\n*todo\n(Moss et al., 2019)\nThe simulation model is a Rust program comprising five files: Lib.rs, main.rs, mixing.rs, run.rs, seir.rs mixing.rs, run.rs, and seir.rs comprise modules for the ‘spatial_seir’ package defined in lib.rs, which is imported to the main.rs program."
  },
  {
    "objectID": "Notes/Compartmental_Models_Markov_Chains.html",
    "href": "Notes/Compartmental_Models_Markov_Chains.html",
    "title": "4  SIS DTMC",
    "section": "",
    "text": "flowchart LR\n    S --> I\n    I --> S\n\n\n\nflowchart LR\n    S --> I\n    I --> S\n\n\n\n\n\n\n\n\nCan be described by a Markov chain of a random variable I(t) representing the number of individuals infected at time t.\n\ndigraph {\n    rankdir = \"LR\"\n    0 -> 0\n    1 -> 0\n    1 -> 2\n    2 -> 1\n    2 -> \"...\"\n    \"...\" -> 2\n    \"...\" -> N\n    N -> \"...\"\n}\n\n\n\n\n   \n\n0\n\n 0   \n\n0->0\n\n    \n\n1\n\n 1   \n\n1->0\n\n    \n\n2\n\n 2   \n\n1->2\n\n    \n\n2->1\n\n    \n\n…\n\n …   \n\n2->…\n\n    \n\n…->2\n\n    \n\nN\n\n N   \n\n…->N\n\n    \n\nN->…\n\n   \n\n\n\n\n\nNote that I(t) = 0 is an absorbing state (i.e. if there are no infectious people they cannot infect anyone). All other states {1,…, N} are transient.\nPossible transitions are specified by\n\np _ {ji} ( \\Delta t ) =\n     \\begin{cases}\n        {\\frac { \\beta i ( N - i ) } { N}} \\Delta t, & {j = i + 1 } \\\\\n        { \\gamma i \\Delta t}, & { j = i - 1 } \\\\\n        { 1 - \\bigg[ \\frac { \\beta i (N - i) } { N } +  \\gamma i }\\bigg] \\Delta t, & { j = i } \\\\\n        0, & { j \\neq i +1, i, i-1}\n    \\end{cases}\n\\tag{4.1}\nWhich can be simplified to\n\np _ {ji} ( \\Delta t ) =\n    \\begin{cases}\n        b(i) \\Delta t, & {j = i + 1 } \\\\\n        d(i) \\Delta t, & { j = i - 1 } \\\\\n        1 - [ b(i)  + d(i)] \\Delta t, & { j = i } \\\\\n        0, & { j \\neq i +1, i, i-1}\n    \\end{cases}\n\\tag{4.2}\nThe probability of being in state i at time t + \\Delta t can be experessed in terms of probabilities at time t. \np_{i}(t + \\Delta t) =\n    p_{i-1}(t)b(i-1)\\Delta t +\n    p_{i+1}(t)d(i+1)\\Delta t +\n    p_{i}(t)(1- [ b(i)  + d(i)] \\Delta t)\n\nfor i = 1,2,..., N, where b(i) = \\beta (N-1/N), and d(i)= \\gamma i\nThe transition matrix P(\\Delta t) is given by \n\\begin{pmatrix}\n    1 & d(1)\\Delta t & 0 &  \\cdots & 0 & 0 \\\\\n    0  & 1-(b+d)(1)\\Delta t & d(2)\\Delta t &  \\cdots & 0 & 0 \\\\\n    0 & b(1)\\Delta t & 1-(b+d)(1)\\Delta t &  \\cdots & 0 & 0 \\\\\n    0 & 0t & b(1)\\Delta &  \\cdots & 0 & 0 \\\\\n    \\vdots & \\vdots & \\vdots &  \\ddots & \\vdots & \\vdots \\\\\n    0 & 0  & 0 &  \\cdots & d(N-1) \\Delta t & 0 \\\\\n    0 & 0  & 0 &  \\cdots & 1-(b+d)(N-1)\\Delta t & d(N) \\Delta t \\\\\n    0 & 0  & 0 &  \\cdots & b(N-1)\\Delta t & 1- d(N) \\Delta t \\\\\n\\end{pmatrix}\n\n\n5 SIR DTMC\nThe compartmental model\n\nflowchart LR\n    S --> I\n    I --> R\n\n\n\nflowchart LR\n    S --> I\n    I --> R\n\n\n\n\n\n\n\n\nCan be described by a Markov chain of two independent random variables S(t) and I(t) representing the number of susceptible or individuals infected at time t, respectively (a third RV R(t) denoting the number of recovered individuals is fully determined when the population size is known, i.e. R = N - S - I).\n\np _ {(s +k, i +j),(s,i)}(\\Delta t) =\n     \\begin{cases}\n        {\\frac { \\beta i s} { N}} \\Delta t, & {(k, j) = (-1, 1) } \\\\\n        { \\gamma i \\Delta t}, & { (k, j) = (0, -1)  } \\\\\n        { 1 - \\bigg[ \\frac { \\beta i s } { N } +  \\gamma i }\\bigg] \\Delta t, & { (k, j) = (0, 0)} \\\\\n        0, & {otherwise}\n    \\end{cases}\n\\tag{5.1}\nEquation 4.1\n\ndigraph {\n    rankdir = \"TB\"\n\n    \"S = 0 \\n I = 1\" ->    \"S = 0 \\n I = 0\" [color = \"blue\"]\n    \"S = 0 \\n I = 2\" ->    \"S = 0 \\n I = 1\" [color = \"blue\"]\n    \"S = 0 \\n I = ~\" ->    \"S = 0 \\n I = 2\" [color = \"blue\"]\n    \"S = 0 \\n I = N\" ->    \"S = 0 \\n I = N - 1\" [color = \"blue\"]\n    \"S = 0 \\n I = N - 1\" -> \"S = 0 \\n I = N - 2\" [color = \"blue\"]\n    \"S = 0 \\n I = N - 2\" -> \"S = 0 \\n I = ~\" [color = \"blue\"]\n\n    \"S = 1 \\n I = 1\" ->    \"S = 0 \\n I = 2\"  [color = \"red\"]\n\n    \"S = 1 \\n I = 2\" ->    \"S = 1 \\n I = 1\" [color = \"blue\"]\n    \"S = 1 \\n I = 2\" ->    \"S = 0 \\n I = ~\" [color = \"red\"]\n\n    \"S = 1 \\n I = ~\" ->    \"S = 1 \\n I = 2\" [color = \"blue\"]\n    \"S = 1 \\n I = ~\" ->    \"S = 0 \\n I = ~\" [color = \"red\"]\n    \"S = 1 \\n I = ~\" ->    \"S = 0 \\n I = N - 1\" [color = \"red\"]\n\n    \"S = 1 \\n I = N - 1\" -> \"S = 1 \\n I = N - 2\" [color = \"blue\"]\n    \"S = 1 \\n I = N - 1\" -> \"S = 0 \\n I = N\" [color = \"red\"]\n\n    \"S = 1 \\n I = N - 2\" -> \"S = 0 \\n I = N - 1\" [color = \"red\"]\n    \"S = 1 \\n I = N - 2\" -> \"S = 1 \\n I = ~\" [color = \"blue\"]\n\n\n    \"S = 2 \\n I = 1\" ->    \"S = 1 \\n I = 2\" [color = \"red\"]\n    \"S = 2 \\n I = 1\" ->    \"S = 2 \\n I = 0\" [color = \"blue\"]\n\n    \"S = 2 \\n I = 2\" ->    \"S = 1 \\n I = ~\" [color = \"red\"]\n    \"S = 2 \\n I = 2\" ->    \"S = 2 \\n I = 1\" [color = \"blue\"]\n\n    \"S = 2 \\n I = ~\" ->    \"S = 1 \\n I = ~\" [color = \"red\"]\n    \"S = 2 \\n I = ~\" ->    \"S = 1 \\n I = N - 2\" [color = \"red\"]\n    \"S = 2 \\n I = ~\" ->    \"S = 2 \\n I = 2\" [color = \"blue\"]\n\n    \"S = 2 \\n I = N - 2\" -> \"S = 1 \\n I = N - 1\" [color = \"red\"]\n    \"S = 2 \\n I = N - 2\" -> \"S = 2 \\n I = ~\" [color = \"blue\"]\n    \n\n    \"S = ~ \\n I = 1\" ->    \"S = ~ \\n I = 0\" [color = \"blue\"]\n    \"S = ~ \\n I = 1\" ->    \"S = ~ \\n I = 2\" [color = \"red\"]\n    \"S = ~ \\n I = 1\" ->    \"S = 2 \\n I = 2\" [color = \"red\"]\n\n    \"S = ~ \\n I = 2\" ->    \"S = ~ \\n I = ~\" [color = \"red\"]\n    \"S = ~ \\n I = 2\" ->    \"S = 2 \\n I = ~\"  [color = \"red\"]\n    \"S = ~ \\n I = 2\" ->    \"S = ~ \\n I = 1\" [color = \"blue\"]\n\n    \"S = ~ \\n I = ~\" ->    \"S = 2 \\n I = ~\" [color = \"red\"]\n    \"S = ~ \\n I = ~\" ->    \"S = 2 \\n I = N - 2\" [color = \"red\"]\n    \"S = ~ \\n I = ~\" ->    \"S = ~ \\n I = ~\"  [color = \"red\"]\n\n    \"S = ~ \\n I = ~\" ->    \"S = ~ \\n I = ~\"  [color = \"blue\"]\n    \"S = ~ \\n I = ~\" ->    \"S = ~ \\n I = 2\" [color = \"blue\"]\n\n\n    \"S = N - 1 \\n I = 1\" ->    \"S = N - 2 \\n I = 2\" [color = \"red\"]\n    \"S = N - 1 \\n I = 1\" ->    \"S = N - 1\\n I = 0\"   [color = \"blue\"]\n\n    \"S = N - 2 \\n I = 1\" -> \"S = ~ \\n I = 2\" [color = \"red\"]\n    \"S = N - 2 \\n I = 1\" -> \"S = N - 2 \\n I = 0\" [color = \"blue\"]\n\n    \"S = N - 2 \\n I = 2\" -> \"S = ~ \\n I = ~\" [color = \"red\"]\n    \"S = N - 2 \\n I = 2\" -> \"S = N - 2 \\n I = 1\" [color = \"blue\"]\n}\n\n\n\n\n   \n\nS = 0 I = 1\n\n S = 0   I = 1   \n\nS = 0 I = 0\n\n S = 0   I = 0   \n\nS = 0 I = 1->S = 0 I = 0\n\n    \n\nS = 0 I = 2\n\n S = 0   I = 2   \n\nS = 0 I = 2->S = 0 I = 1\n\n    \n\nS = 0 I = ~\n\n S = 0   I = ~   \n\nS = 0 I = ~->S = 0 I = 2\n\n    \n\nS = 0 I = N\n\n S = 0   I = N   \n\nS = 0 I = N - 1\n\n S = 0   I = N - 1   \n\nS = 0 I = N->S = 0 I = N - 1\n\n    \n\nS = 0 I = N - 2\n\n S = 0   I = N - 2   \n\nS = 0 I = N - 1->S = 0 I = N - 2\n\n    \n\nS = 0 I = N - 2->S = 0 I = ~\n\n    \n\nS = 1 I = 1\n\n S = 1   I = 1   \n\nS = 1 I = 1->S = 0 I = 2\n\n    \n\nS = 1 I = 2\n\n S = 1   I = 2   \n\nS = 1 I = 2->S = 0 I = ~\n\n    \n\nS = 1 I = 2->S = 1 I = 1\n\n    \n\nS = 1 I = ~\n\n S = 1   I = ~   \n\nS = 1 I = ~->S = 0 I = ~\n\n    \n\nS = 1 I = ~->S = 0 I = N - 1\n\n    \n\nS = 1 I = ~->S = 1 I = 2\n\n    \n\nS = 1 I = N - 1\n\n S = 1   I = N - 1   \n\nS = 1 I = N - 1->S = 0 I = N\n\n    \n\nS = 1 I = N - 2\n\n S = 1   I = N - 2   \n\nS = 1 I = N - 1->S = 1 I = N - 2\n\n    \n\nS = 1 I = N - 2->S = 0 I = N - 1\n\n    \n\nS = 1 I = N - 2->S = 1 I = ~\n\n    \n\nS = 2 I = 1\n\n S = 2   I = 1   \n\nS = 2 I = 1->S = 1 I = 2\n\n    \n\nS = 2 I = 0\n\n S = 2   I = 0   \n\nS = 2 I = 1->S = 2 I = 0\n\n    \n\nS = 2 I = 2\n\n S = 2   I = 2   \n\nS = 2 I = 2->S = 1 I = ~\n\n    \n\nS = 2 I = 2->S = 2 I = 1\n\n    \n\nS = 2 I = ~\n\n S = 2   I = ~   \n\nS = 2 I = ~->S = 1 I = ~\n\n    \n\nS = 2 I = ~->S = 1 I = N - 2\n\n    \n\nS = 2 I = ~->S = 2 I = 2\n\n    \n\nS = 2 I = N - 2\n\n S = 2   I = N - 2   \n\nS = 2 I = N - 2->S = 1 I = N - 1\n\n    \n\nS = 2 I = N - 2->S = 2 I = ~\n\n    \n\nS = ~ I = 1\n\n S = ~   I = 1   \n\nS = ~ I = 1->S = 2 I = 2\n\n    \n\nS = ~ I = 0\n\n S = ~   I = 0   \n\nS = ~ I = 1->S = ~ I = 0\n\n    \n\nS = ~ I = 2\n\n S = ~   I = 2   \n\nS = ~ I = 1->S = ~ I = 2\n\n    \n\nS = ~ I = 2->S = 2 I = ~\n\n    \n\nS = ~ I = 2->S = ~ I = 1\n\n    \n\nS = ~ I = ~\n\n S = ~   I = ~   \n\nS = ~ I = 2->S = ~ I = ~\n\n    \n\nS = ~ I = ~->S = 2 I = ~\n\n    \n\nS = ~ I = ~->S = 2 I = N - 2\n\n    \n\nS = ~ I = ~->S = ~ I = 2\n\n    \n\nS = ~ I = ~->S = ~ I = ~\n\n    \n\nS = ~ I = ~->S = ~ I = ~\n\n    \n\nS = N - 1 I = 1\n\n S = N - 1   I = 1   \n\nS = N - 2 I = 2\n\n S = N - 2   I = 2   \n\nS = N - 1 I = 1->S = N - 2 I = 2\n\n    \n\nS = N - 1I = 0\n\n S = N - 1  I = 0   \n\nS = N - 1 I = 1->S = N - 1I = 0\n\n    \n\nS = N - 2 I = 2->S = ~ I = ~\n\n    \n\nS = N - 2 I = 1\n\n S = N - 2   I = 1   \n\nS = N - 2 I = 2->S = N - 2 I = 1\n\n    \n\nS = N - 2 I = 1->S = ~ I = 2\n\n    \n\nS = N - 2 I = 0\n\n S = N - 2   I = 0   \n\nS = N - 2 I = 1->S = N - 2 I = 0\n\n   \n\n\n\n\n\nThere are (N + 1)(N + 2)/2 ordered pairs of states (s, i)\n\nN = 100\nS = 0:N\nI = 0:N\n\nn = Int64((N+1)*(N+2)/2)\n\na = Base.product(S, I) |> collect |> vec\nb = []\n\nfor i in a\n    if sum(i) <= N\n        push!(b, i)\n    end\nend\n\n\nusing NamedArrays\nusing SparseArrays\nβ = 0.5\nγ = 0.1\nQ = zeros(Float64, lastindex(b), lastindex(b))\n\nfor i in eachindex(b)\n    iS, iI = b[i]\n    for j in eachindex(b)\n        jS, jI = b[j]\n        if iS - jS == 1 && iI - jI == -1 ## Infection condition\n            Q[i, j] = β*iS*iI/N\n        elseif  iS == jS && iI - jI == 1 ## recovery condition\n            Q[i, j] = γ*iI\n        elseif  iS == jS  && iI == jI \n            Q[i, j] = -((β*iS*iI/N) + γ*iI)\n        end\n    end\nend\n\n\nusing ExponentialUtilities\nt = 10\n\nx0 = (25, 30)\nx0i = findfirst(x -> x == x0, b)\n\np0 = zeros(lastindex(b))\np0[x0i] = 1\n\npt = expv(t, Q, p0)\n\n5151-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\nunpack the state vector\n\nSImat = zeros(N+1, N+1)\npS = zeros(N+1)\npI = zeros(N+1)\n\nfor i in eachindex(pt)\n    S, I = b[i]\n    pS[S+1] += pt[i]\n    pI[I+1] += pt[i] \n    SImat[S+1, I+1] = pt[i]\nend\n\n\nusing StatsPlots\nplot(pS)\nheatmap(SImat)"
  },
  {
    "objectID": "Notes/CTMC_SIR_Sim.html",
    "href": "Notes/CTMC_SIR_Sim.html",
    "title": "5  Gillespie simulation",
    "section": "",
    "text": "To begin, lets define the disease model.\nThe SIR compartmental model features 3 compartiments (Susceptible, Infectious, and Recovered) though which N individuals pass between (i.e. S + I + R = N) over time. To impliment this, lets define a type to represent the state of an SIR system at time t, X(t) = \\{S, I, R\\}.\n\nSIR_state = @NamedTuple begin\n    t::Real\n    S::Int\n    I::Int\n    R::Int\nend\n\nNamedTuple{(:t, :S, :I, :R), Tuple{Real, Int64, Int64, Int64}}\n\n\n\ndigraph SIR {\n    rankdir = \"LR\"\n    S->I\n    I->R\n}\n\n\n\n\n\n\nSIR\n\n  \n\nS\n\n S   \n\nI\n\n I   \n\nS->I\n\n    \n\nR\n\n R   \n\nI->R\n\n   \n\n\n\n\n\nLets initialise a population of N = 100 individuals, one of who is infected and the remaining 99 are Susceptible along with a data frame to record the state at time t = 0.\n\nX0 = SIR_state([0.0,99,1,0])\n\nusing DataFrames\n\nSIR_CTMC = DataFrame(\n    t = Vector{Float64}(),\n    S = Vector{Int64}(),\n    I = Vector{Int64}(),\n    R = Vector{Int64}())\n\npush!(SIR_CTMC, X0)\n\n\n1×4 DataFrameRowtSIRFloat64Int64Int64Int6410.09910\n\n\nIn an SIR system there are two possible events that can occur after a certain time \\Delta t: infection (i.e. an individual moves from the Susceptible compartment to the Infectious compartment) X(t + \\Delta t) = \\{s-1, i + 1, r\\} and recovery X(t + \\Delta t) = \\{s, i-1, r +1\\}. Lets define these as triples which we can add to our SIR_State variable\n\nSIR_events = (\n    infection = [-1, 1, 0],\n    recovery = [0,-1,1]\n)\n\n(infection = [-1, 1, 0], recovery = [0, -1, 1])\n\n\nOnly one eveCTMC model of a SIR disease process. which event will occur? Epidemiologcal theory tells us that, assuming homogenous mixing of infectious and susceptible individuals there will be S \\times I opportunities for contact. Only a proportion of these opporunities will result in infection, so let the parameter \\beta, the ‘transmission rate’ modulate this.\n\np = (\n    β = 0.5,\n    γ = 0.1\n    )\n\n(β = 0.5, γ = 0.1)\n\n\nSimiularly, we’ll specify a constant parameter, \\lambda, which will modulate the rate of recovery. Lets define a ‘transition’ function which, given a state X(t) = \\{s, i,r\\} will return the ‘propensity’ of each event occurring\n\nfunction Transition_Function(X, p)\n    (β, γ) = p\n    (t,S,I,R) = X\n    N = S + I + R\n    infection = (β/N)*S*I\n    recovery = γ*I\n    [infection,recovery]\nend;\n\nOk thats enough setting up, lets simulate the evolution of the system throrugh time.\nDelta t will have an exponential distribution with parameter 1/\\sum{a+b}\n\nusing Distributions\n\nΔt = rand(Exponential(1/sum(Transition_Function(X0,p))))\n\n0.6968465641840451\n\n\nNext we need to determine which event will happen. The probability of a transition will be given by the proportion of the\n\nPt = Transition_Function(X0,p)\nPi = Pt[1]/sum(Pt)\nPr = Pt[2]/sum(Pt)\n\n0.16806722689075632\n\n\nTo sample one event with probability weighting according to its relative propensity,\n\nr= rand() \ni = 1\ncw = Pt[1]\nwhile cw < r && i < length(Pt)\n    i += 1\n    @inbounds cw += Pt[i]\nend\n\nΔx = SIR_events[i]\n\nXt = SIR_state(collect(X0) + [Δt; Δx])\n\npush!(SIR_CTMC, Xt)\n\n\n2×4 DataFrameRowtSIRFloat64Int64Int64Int6410.0991020.6968479820\n\n\nWe’re going to want to run this stepping process a number of times, so lets repeat the process until some specified time (t_{end}) is reached\n\ntend = 50\nt = Xt[1]\n\nwhile t < tend\n    Δt = rand(Exponential(1/sum(Transition_Function(Xt, p))))\n\n    Pt = Transition_Function(Xt,p)\n    Ptn = Pt ./ sum(Pt)\n\n    i = 1\n    cw = Ptn[1]\n    while cw < rand() && i < length(Ptn)\n        i += 1\n        @inbounds cw += Ptn[i]\n    end\n\n    Δx = SIR_events[i]\n\n    Xt = SIR_state(collect(Xt) + [Δt; Δx])\n\n    push!(SIR_CTMC, Xt)\n\n    t = Xt[1]\nend\n\nlets plot the results for a clearer picture\n\nusing StatsPlots\n\n@df SIR_CTMC plot(:t, [:S, :I, :R] )\n\n\n\n\nThe probability that a susceptible individual will become infected p_{s-1, i+1}\\leftarrow{s, i} = \\frac\nSince R = S+I -N, se can represent the state of the system with \\{S, I\\}, where S \\in \\{0,1, ... , N-I-R\\}, I \\in \\{0,1, ... , N-S-R\\}.\nfor example, when N = 3, we can represent the system with a graph:\nAs a discrete time process this Markov chain can be represented by the transition matrix \np = \\begin{bmatrix}\n\\end{bmatrix}\n\nlooks reasonable. How about in comparison to the deterministic ODE solution\n\nusing DifferentialEquations\n\nfunction SIRModel!(du, u, p, t)\n    S, I, R = u\n    β, γ = p\n    du[1] = -β*S*I\n    du[2] = β*S*I-γ*I\n    du[3] = γ*I\nend \n\np = [.005,.1]\nu0 = [99,1,0]\ntspan = (0.0, 50)\n\nprob = ODEProblem(SIRModel!, u0, tspan, p)\n\nsol = solve(prob)\n\nplot!(sol)\n\n\n\n\nThey’re not identical but maybe this is to be expected given the small sample size. We could inrease the sample size (which extended to would equal the ODE), but lets instead perform the N = 100 simulation a few more times.\nFor convenience I’ll wrap the whole simulation in a function which takes initial conditions and parameters in and outputs the data\n\nfunction SIR_sim(X0::Vector{Int64}, tmax, p)\n    N = sum(X0)\n    Xt = SIR_state([0; X0])\n\n    SIR_events = (\n        infection = [-1, 1, 0],\n        recovery = [0,-1,1]\n    )\n\n    function Transition_Function(X, p)\n        (β, γ) = p\n        (t, S,I,R) = X\n        infection = β/N*S*I\n        recovery = γ*I\n        [infection,recovery]\n    end\n\n    SIR_CTMC = DataFrame(\n    t = Vector{Float64}(),\n    S = Vector{Int64}(),\n    I = Vector{Int64}(),\n    R = Vector{Int64}())\n\n\n    push!(SIR_CTMC, Xt)\n    t = Xt[1]\n    tmax = tmax\n    while t < tmax\n        Pt = Transition_Function(Xt, p)\n        Ptn = Pt ./ sum(Pt)\n\n        i = 1\n        cw = Ptn[1]\n        while cw < rand() && i < length(Ptn)\n            i += 1\n            @inbounds cw += Ptn[i]\n        end\n\n        Δx = SIR_events[i]\n        Δt = rand(Exponential(1/sum(Pt)))\n\n        Xt = SIR_state(collect(Xt) + [Δt; Δx])\n\n        push!(SIR_CTMC, Xt)\n\n        t += Δt\n   \n\n    end\n     return SIR_CTMC\nend\n\nSIR_sim (generic function with 1 method)\n\n\nand run this 100 times\n\ntmax = 50.0\nX0 = [99,1,0]\nparams = [.5, .1]\nNsims = 100\nSims = DataFrame(\n    t = Vector{Vector{Float64}}(),\n    S = Vector{Vector{Int64}}(),\n    I = Vector{Vector{Int64}}(),\n    R = Vector{Vector{Int64}}()) \n\nfor i in 1:Nsims\n    sim = SIR_sim(X0, tmax, params)\n    push!(Sims.t, sim.t)\n    push!(Sims.S, sim.S)\n    push!(Sims.I, sim.I)\n    push!(Sims.R, sim.R)\nend\n\nI’ll also remove any samples in which the epidemic does not spread (i.e. when i = 0 and s != 0)\n\nextinction_i = falses(Nsims)\nfor i in eachindex(Sims.t)\n    extinction_i[i] = false\n    extinction = false\n    while extinction != true \n        for j in eachindex(Sims.S[i])\n            if Sims.I[i][j] == 0 && Sims.S[i][j] != 0\n                extinction_i[i] = true\n                extinction = true\n            elseif  j == lastindex(Sims.t[i])\n                extinction = true\n                break\n            end\n        end\n    end\nend\n\n\nSims = Sims[extinction_i .== false, :] \n\nplot()\nfor i in 1:length(Sims.t)\n   global Ploto = @df Sims plot!(:t[i], [:S[i] :I[i] :R[i]], \n    vars = [:t, :S, :I, :R], linecolor = [:blue :red :green], linealpha = 0.1, legend = false, xlim = [0,tmax]) \nend\n\nPloto\n\n\n\n\nTo summarise our data, it will be useful to be able to produce the distribution of states (across a number of samples) at a particular time t. I’ll write a function to do this\n\nstateatt = function(t, Sims)\n\n    function lastindexbeoforet(t, V)\n        i = firstindex(V)\n        while V[i] <  t\n            i +=1\n        end\n        i-1\n    end\n\n    tis = lastindexbeoforet.(fill(t, lastindex(Sims.t)), Sims.t)\n[getindex.(Sims.S, tis),\n getindex.(Sims.I, tis),\n getindex.(Sims.R, tis)]\nend\n\n#16 (generic function with 1 method)\n\n\nWe can use this function to define an average over all the our samples throught the course of the simulation.\n\nt = 1:0.1:tmax\n\nSIR_Mean = DataFrame( \n    t = Vector{Float64}(),\n    S = Vector{Float64}(),\n    I = Vector{Float64}(),\n    R = Vector{Float64}())\n\n\nfor i in t\n    Xt = stateatt(i, Sims)\n    Xtbar = mean.(Xt)\n    push!(SIR_Mean, [i;Xtbar]) \nend\n\n\nPloto\n@df SIR_Mean plot!(:t, [:S, :I, :R], vars = [:t, :S, :I, :R], linecolor = [:blue :red :green])\n\n\n\n\nWe can also check the distribution of states at any given time. lets check t = 15\n\nt = 10\nS, I, R = stateatt(t, Sims)\nSims_plot_df = DataFrame(S = S, I = I, R = R) |> \n    x -> stack(x, 1:3)\n@df Sims_plot_df density(:value, group = :variable)\n\n\n\n\nA nice snapshot, but maybe we should animate the progression\n\nanim = @animate for i in 1:0.5:tmax\n    S, I, R = stateatt(i, Sims)\n    Sims_plot_df = DataFrame(S = S, I = I, R = R) |> \n        x -> stack(x, 1:3)\n    @df Sims_plot_df density(:value, group = :variable, alpha = 0.5, xlims = [0, 100], bins = 50)\nend\n\ngif(anim)\n\n[ Info: Saved animation to C:\\Users\\Reubender\\Documents\\Projects\\SCI499\\papers\\Thesis\\Notes\\tmp.gif\n\n\n\n\n\n\ntmax = 50\n\nanim = @animate for i in 1:0.5:tmax\n    S, I, R = stateatt(i, Sims)\n    Sims_plot_df = DataFrame(S = S, I = I, R = R) \n     @df Sims_plot_df histogram2d(:S, :I, xlims = [0, 100], ylims = [0,100], bins = (50,50), colour = :plasma)\nend\n\ngif(anim)\n\n[ Info: Saved animation to C:\\Users\\Reubender\\Documents\\Projects\\SCI499\\papers\\Thesis\\Notes\\tmp.gif"
  },
  {
    "objectID": "Notes/shapefiles.html",
    "href": "Notes/shapefiles.html",
    "title": "6  Maps and shapefiles in julia",
    "section": "",
    "text": "using Shapefile\n\nASGSdir = joinpath(datadir(),\"ASGS_GDA2020\")\n\n(AUS_SHP,\nGCCSA_SHP,\nMB_SHP,\nSA1_SHP,\nSA2_SHP,\nSA3_SHP,\nSA4_SHP, \nSTE_SHP) = Shapefile.Table.(joinpath.(joinpath(ASGSdir),\n                readdir(ASGSdir),\n                string.(replace.(readdir(ASGSdir), r\"_SHP\" => \"\"),\n                 \".shp\")))\n\n8-element Vector{Shapefile.Table{Union{Missing, Shapefile.Polygon}}}:\n Shapefile.Table{Union{Missing, Shapefile.Polygon}} with 2 rows and the following 7 columns:\n    \ngeometry, AUS_CODE21, AUS_NAME21, CHG_FLAG21, CHG_LBL21, AREASQKM21, LOCI_URI21\n\n Shapefile.Table{Union{Missing, Shapefile.Polygon}} with 35 rows and the following 11 columns:\n    \ngeometry, GCC_CODE21, GCC_NAME21, CHG_FLAG21, CHG_LBL21, STE_CODE21, STE_NAME21, AUS_CODE21, AUS_NAME21, AREASQKM21, LOCI_URI21\n\n Shapefile.Table{Union{Missing, Shapefile.Polygon}} with 368286 rows and the following 20 columns:\n    \ngeometry, MB_CODE21, MB_CAT21, CHG_FLAG21, CHG_LBL21, SA1_CODE21, SA2_CODE21, SA2_NAME21, SA3_CODE21, SA3_NAME21, SA4_CODE21, SA4_NAME21, GCC_CODE21, GCC_NAME21, STE_CODE21, STE_NAME21, AUS_CODE21, AUS_NAME21, AREASQKM21, LOCI_URI21\n\n Shapefile.Table{Union{Missing, Shapefile.Polygon}} with 61845 rows and the following 18 columns:\n    \ngeometry, SA1_CODE21, CHG_FLAG21, CHG_LBL21, SA2_CODE21, SA2_NAME21, SA3_CODE21, SA3_NAME21, SA4_CODE21, SA4_NAME21, GCC_CODE21, GCC_NAME21, STE_CODE21, STE_NAME21, AUS_CODE21, AUS_NAME21, AREASQKM21, LOCI_URI21\n\n Shapefile.Table{Union{Missing, Shapefile.Polygon}} with 2473 rows and the following 17 columns:\n    \ngeometry, SA2_CODE21, SA2_NAME21, CHG_FLAG21, CHG_LBL21, SA3_CODE21, SA3_NAME21, SA4_CODE21, SA4_NAME21, GCC_CODE21, GCC_NAME21, STE_CODE21, STE_NAME21, AUS_CODE21, AUS_NAME21, AREASQKM21, LOCI_URI21\n\n Shapefile.Table{Union{Missing, Shapefile.Polygon}} with 359 rows and the following 15 columns:\n    \ngeometry, SA3_CODE21, SA3_NAME21, CHG_FLAG21, CHG_LBL21, SA4_CODE21, SA4_NAME21, GCC_CODE21, GCC_NAME21, STE_CODE21, STE_NAME21, AUS_CODE21, AUS_NAME21, AREASQKM21, LOCI_URI21\n\n Shapefile.Table{Union{Missing, Shapefile.Polygon}} with 108 rows and the following 13 columns:\n    \ngeometry, SA4_CODE21, SA4_NAME21, CHG_FLAG21, CHG_LBL21, GCC_CODE21, GCC_NAME21, STE_CODE21, STE_NAME21, AUS_CODE21, AUS_NAME21, AREASQKM21, LOCI_URI21\n\n Shapefile.Table{Union{Missing, Shapefile.Polygon}} with 10 rows and the following 9 columns:\n    \ngeometry, STE_CODE21, STE_NAME21, CHG_FLAG21, CHG_LBL21, AUS_CODE21, AUS_NAME21, AREASQKM21, LOCI_URI21\n\n\nCreate an index of the SA3 regions in the Greater Melbourne GCC\n\nusing Tables\n\nGMelb_SA1_SHP,\nGMelb_SA2_SHP,\nGMelb_SA3_SHP,\nSGMelb_A4_SHP = (\n    SA1_SHP,\n    SA2_SHP,\n    SA3_SHP,\n    SA4_SHP) .|>\n     x -> Tables.subset(x, x.GCC_NAME21 .== \"Greater Melbourne\")\n\n(Tables.DictColumnTable with 11487 rows, 18 columns, and schema:\n :geometry    Union{Missing, Shapefile.Polygon}\n :SA1_CODE21  Union{Missing, String}\n :CHG_FLAG21  Union{Missing, String}\n :CHG_LBL21   Union{Missing, String}\n :SA2_CODE21  Union{Missing, String}\n :SA2_NAME21  Union{Missing, String}\n :SA3_CODE21  Union{Missing, String}\n :SA3_NAME21  Union{Missing, String}\n :SA4_CODE21  Union{Missing, String}\n :SA4_NAME21  Union{Missing, String}\n :GCC_CODE21  Union{Missing, String}\n :GCC_NAME21  Union{Missing, String}\n :STE_CODE21  Union{Missing, String}\n :STE_NAME21  Union{Missing, String}\n :AUS_CODE21  Union{Missing, String}\n :AUS_NAME21  Union{Missing, String}\n :AREASQKM21  Union{Missing, Float64}\n :LOCI_URI21  Union{Missing, String}, Tables.DictColumnTable with 361 rows, 17 columns, and schema:\n :geometry    Union{Missing, Shapefile.Polygon}\n :SA2_CODE21  Union{Missing, String}\n :SA2_NAME21  Union{Missing, String}\n :CHG_FLAG21  Union{Missing, String}\n :CHG_LBL21   Union{Missing, String}\n :SA3_CODE21  Union{Missing, String}\n :SA3_NAME21  Union{Missing, String}\n :SA4_CODE21  Union{Missing, String}\n :SA4_NAME21  Union{Missing, String}\n :GCC_CODE21  Union{Missing, String}\n :GCC_NAME21  Union{Missing, String}\n :STE_CODE21  Union{Missing, String}\n :STE_NAME21  Union{Missing, String}\n :AUS_CODE21  Union{Missing, String}\n :AUS_NAME21  Union{Missing, String}\n :AREASQKM21  Union{Missing, Float64}\n :LOCI_URI21  Union{Missing, String}, Tables.DictColumnTable with 40 rows, 15 columns, and schema:\n :geometry    Union{Missing, Shapefile.Polygon}\n :SA3_CODE21  Union{Missing, String}\n :SA3_NAME21  Union{Missing, String}\n :CHG_FLAG21  Union{Missing, String}\n :CHG_LBL21   Union{Missing, String}\n :SA4_CODE21  Union{Missing, String}\n :SA4_NAME21  Union{Missing, String}\n :GCC_CODE21  Union{Missing, String}\n :GCC_NAME21  Union{Missing, String}\n :STE_CODE21  Union{Missing, String}\n :STE_NAME21  Union{Missing, String}\n :AUS_CODE21  Union{Missing, String}\n :AUS_NAME21  Union{Missing, String}\n :AREASQKM21  Union{Missing, Float64}\n :LOCI_URI21  Union{Missing, String}, Tables.DictColumnTable with 9 rows, 13 columns, and schema:\n :geometry    Union{Missing, Shapefile.Polygon}\n :SA4_CODE21  Union{Missing, String}\n :SA4_NAME21  Union{Missing, String}\n :CHG_FLAG21  Union{Missing, String}\n :CHG_LBL21   Union{Missing, String}\n :GCC_CODE21  Union{Missing, String}\n :GCC_NAME21  Union{Missing, String}\n :STE_CODE21  Union{Missing, String}\n :STE_NAME21  Union{Missing, String}\n :AUS_CODE21  Union{Missing, String}\n :AUS_NAME21  Union{Missing, String}\n :AREASQKM21  Union{Missing, Float64}\n :LOCI_URI21  Union{Missing, String})\n\n\n\nusing Plots\nGMelb_SA1_SHP.geometry |> plot"
  },
  {
    "objectID": "Notes/Moss.html#mixture-matrix-construction",
    "href": "Notes/Moss.html#mixture-matrix-construction",
    "title": "3  Replicating Moss et al. 2019",
    "section": "3.1 Mixture Matrix Construction",
    "text": "3.1 Mixture Matrix Construction\nThe first task is to import the population data which will ultiamtely comprise a mixing matrix. The main components here are an population table (describing the number of individuals in a given SA 3 region) and an origin destination matrix, which specifies how much individuals travel between regions. These two files are composed to a dedictated type ‘OdMat’ which contains the matrix, population numbers and names of the regions\n\nstruct OdMat\n    m::Array{Float64, 2}\n    names::Vector{String}\n    popns::Array{Int, 1}\nend\n\nThe population data for a given set of names is imported by the the funciton “read_popn”\n\nusing CSV\nusing DataFrames\n\nfunction read_popns(path::AbstractString, names::Vector{String})::Vector{Int}\n    reader = CSV.read(path,DataFrame)\n    popn_tbl = Dict{String, Int}()\n    for row in eachrow(reader)\n        name = row[2]\n        if haskey(popn_tbl, \"$name\")\n            error(\"Multiple populations for $name\")\n        else\n            value = row[3]\n            popn_tbl[\"$name\"] = value\n        end\n    end\n    popns = Vector{Int}()\n    for name in names\n        if haskey(popn_tbl, \"$name\")\n            push!(popns, popn_tbl[\"$name\"])\n        else\n            error(\"No population defined for $name\")\n        end\n    end\n    return popns\nend\n\nread_popns (generic function with 1 method)\n\n\nodin the data file are found using the find_mm function\n\nusing Match\n\nfunction find_mm(path, subdir::Bool)::Vector{String}\n    files = []\n    for entry in readdir(path, join = true)\n        f = entry\n        if f|>isfile\n            ext = split(f, \".\")[2]\n            @match ext begin\n                \"csv\" => push!(files, f)\n            end\n        elseif f|>isdir && subdir\n            for sub_entry in readdir(f, join = true)\n                sub_f = sub_entry\n                if sub_f|>isfile\n                    ext = split(sub_f, \".\")[2]\n                    @match ext begin\n                        \"csv\" => push!(files, sub_f)\n                    end\n                end\n            end\n        end\n    end\n    files|>sort!\n    files\nend\n\nfind_mm (generic function with 1 method)\n\n\nAnd then imported and combined with population data via ‘read_OdMat’\n\nfunction read_OdMat(mm_path::AbstractString, popn_path::AbstractString)::OdMat\n    reader = CSV.read(ODdir, DataFrame)\n    names = Vector{String}()\n    values = Vector{Float64}()\n    for row in eachrow(reader)\n        push!(names, string(row[1]))\n        for val in row[2:end]\n            push!(values, val)\n        end\n    end\n    \n    n = length(names)\n    mat = reshape(values, (n, n))\n    popns = read_popns(popn_path, names)\n    \n     OdMat(mat, names, popns)\nend\n\nread_OdMat (generic function with 1 method)\n\n\n\nODdir = datadir(\"Moss2018\\\\mixing\\\\abs_public.csv\")\npopdir = datadir(\"Moss2018\\\\mixing\\\\sa3-populations.ssv\")\n\nOD = read_OdMat(ODdir, popdir)\n\nOdMat([0.0 0.0126702534050681 … 0.00829 0.00355; 0.00497014910447313 0.0 … 0.0019 0.00103; … ; 0.000160004800144004 0.000100002000040001 … 0.0 0.00208; 0.000610018300549016 0.000430008600172003 … 0.0169 0.0], [\"20601\", \"20602\", \"20603\", \"20604\", \"20605\", \"20606\", \"20607\", \"20701\", \"20702\", \"20703\"  …  \"21201\", \"21202\", \"21203\", \"21204\", \"21205\", \"21301\", \"21302\", \"21303\", \"21304\", \"21305\"], [91653, 55271, 70367, 148041, 108569, 67798, 94234, 177361, 95593, 107256  …  97790, 137519, 176002, 197453, 184848, 196858, 88342, 87355, 160293, 233138])\n\n\nA mixture matrix object (::MixMat) stores this OD matrix in affition information about the fraction of trips that are taken within individual regions (this can either be a constant across all regions, or vary between regions) and a dedicatied fraction for trips to the cbd (which will be useful for modelling later on).\nThe option between constant (::Uniform) or different (::Variable) fractions of self-trips is encoded in its own type hierarchy\n\nabstract type FracSelf end\nstruct Uniform{Float64} <: FracSelf \n    a::Float64\nend\nstruct Variable{Array} <: FracSelf end\n\nWhich is an attribute of the MixMat type\n\nstruct MixMat\n    m::Array{Real, 2}\n    names::Vector{String}\n    popns::Array{Int, 1}\n    frac_self::FracSelf\n    frac_cbd::Real\nend\n\nBefore actually instantiating this MixMat, there are some checks and scalings to make sure it comes out right (i’m not actually sure what this achieves yet, but I’ll keep it in for now.)\n\nusing LinearAlgebra\nfunction scale_diag_var!(mat::Matrix{T}, frac_self::Vector{T}) where T<:AbstractFloat\n    @inbounds for i in 1:size(mat, 1)\n        mat[i, :] = mat[i, :] .* ((1.0 - frac_self[i]) ./ sum(mat[i, :]))\n    end\n    diag(mat) .= frac_self\nend\n\nfunction scale_diag_unif!(mat::Matrix{T}, frac_self) where T<:AbstractFloat\n    frac_mix = 1.0 - frac_self\n    @inbounds for i in 1:size(mat, 1)\n        mat[i, :] = mat[i, :] .* (frac_mix ./ sum(mat[i, :]))\n    end\n    diag(mat) .= frac_self\nend\n\nfunction scale_diag!(mat::Matrix{T}, frac_self) where T<:AbstractFloat\n    if isa(frac_self, Uniform)\n        scale_diag_unif!(mat, frac_self.a)\n    elseif isa(frac_self, Variable)\n        scale_diag_var!(mat, frac_self.x)\n    end\nend\n\nfunction test_scale_diag(mat::Matrix{T}, frac_self::T) where T<:AbstractFloat\n    m1 = copy(mat)\n    scale_diag_unif!(m1, frac_self)\n\n    m2 = copy(mat)\n    fs2 = fill(frac_self, size(mat, 1))\n    scale_diag_var!(m2, fs2)\n\n    m3 = copy(mat)\n    fs3 = fill(frac_self, size(mat, 1))\n    fs3[2] *= 0.9\n    scale_diag_var!(m3, fs3)\n\n    @assert all(abs.(1.0 .- sum(m1, dims=2)) .< 1e-8) \"m1 rowsum\"\n    @assert all(abs.(1.0 .- sum(m2, dims=2)) .< 1e-8) \"m2 rowsum\"\n    @assert all(abs.(1.0 .- sum(m3, dims=2)) .< 1e-8) \"m3 rowsum\"\n    @assert m1 == m2 \"mixing matrices differ\"\n    @assert m1 != m3 \"mixing matrices do not differ\"\nend\n\nfunction redistribute!(mat::Matrix{Float64}, popns::Vector{Int},\n    frac_cbd::Float64, cbd_ix::Int)\n    # Determine how much all other regions mix with the CBD.\n    mix_w_cbd = copy(mat[:, cbd_ix])\n    mix_w_cbd[cbd_ix] = 0.0\n\n    # Weight the mixing by each region's resident population.\n    mix_w_cbd .= mix_w_cbd .* Float64.(popns)\n\n    # Normalise these values to conserve the force of infection.\n    mix_w_cbd /= sum(mix_w_cbd)\n\n        for rix in 1:size(mat, 1)\n            if rix == cbd_ix\n                continue\n            end\n\n        row = mat[rix, :]\n        cbd_mix = row[cbd_ix]\n        add_mix = [cbd_mix * (1.0 - frac_cbd) * v for v in mix_w_cbd]\n        row += add_mix\n        row[cbd_ix] = cbd_mix * frac_cbd\n        mat[rix, :] = row\n    end\nend\n\nredistribute! (generic function with 1 method)\n\n\nWith these in place, we can define the constructor for the mixture matrix, taking an OD matrix with fractions of self and cbd mixing as input.\n\nfunction new_MixMat(od::OdMat, frac_self::FracSelf, frac_cbd::Float64)::MixMat\n    mat = copy(od.m)\n    names = copy(od.names)\n    popns = copy(od.popns)\n    scale_diag!(mat, frac_self)\n    cbd_ix = findfirst(isequal(\"20604\"), names)\n    redistribute!(mat, popns, frac_cbd, cbd_ix)\n    MixMat(mat, names, popns, frac_self, frac_cbd)\nend\n\nnew_MixMat (generic function with 1 method)\n\n\nNow we can create our final mixing matrix with OD and some values for frac_self and frac_cbd\n\nfrac_self = Uniform(0.5)\nfrac_cbd = 0.2\n\nmixmat = new_MixMat(OD, frac_self, frac_cbd)\n\nMixMat(Real[0.001509960074415217 0.022729530914353313 … 0.015063435697675473 0.008498565379626576; 0.020184561410073135 0.0002905733134707393 … 0.00768857144195623 0.0052909381405588166; … ; 0.003993908953092068 0.002410274797532776 … 0.00010569704882979673 0.048447251137912824; 0.004211899778551643 0.0026433492396756623 … 0.09223036054490781 0.0013466067803184732], [\"20601\", \"20602\", \"20603\", \"20604\", \"20605\", \"20606\", \"20607\", \"20701\", \"20702\", \"20703\"  …  \"21201\", \"21202\", \"21203\", \"21204\", \"21205\", \"21301\", \"21302\", \"21303\", \"21304\", \"21305\"], [91653, 55271, 70367, 148041, 108569, 67798, 94234, 177361, 95593, 107256  …  97790, 137519, 176002, 197453, 184848, 196858, 88342, 87355, 160293, 233138], Uniform{Float64}(0.5), 0.2)\n\n\nWe have our mixing matrix (in the ::MixMat type) ready for input into a SEIR Model"
  },
  {
    "objectID": "Notes/Moss.html#seir-model",
    "href": "Notes/Moss.html#seir-model",
    "title": "3  Replicating Moss et al. 2019",
    "section": "3.2 SEIR Model",
    "text": "3.2 SEIR Model\n\nstruct Params\n    β::Float64\n    σ::Float64\n    γ::Float64\n    popn::Vector #Vector of patch sizes\n    mixmat::AbstractArray\nend\n\n\nmutable struct Model\n    params::Params\n    numpatch::Int\n    t::Float64\n    s::Vector\n    e::Vector\n    i::Vector\nend\n\nMake a new model object from parameter set and an initial exposure number\n\nfunction new_model(params::Params, e0::Int)\n    #first block selects a random patch from those in the model\n    let \n        n_patch = params.popn |> length\n        rand_choice = rand() |> nextfloat\n        ix = (rand_choice*n_patch) |> trunc\n        @assert ix < n_patch \"Selected patch $ix of $n_patch, from $rand_choice\"\n        s0 = params.popn\n        ##then creates a 'Model' object with the provided parameters\n        m = Model(\n            params = params,\n            n_patch = n_patch,\n            t = 0.0,\n            s = s0,\n            e = zeros(n_patch),\n            i = zeros(n_patch)\n            )\n            ##and sets the number of exposures to e0\n        m.s[ix] -= e0 \n        m.e[ix] += e0 \n        # and returns the model\n        m\n    end\nend\n\nnew_model (generic function with 1 method)\n\n\n\nfunction event_rates(m::Model)::Array{Float64, 1}\n    let \n        rates = zeros(3*(m.params.popn|> length))\n        s_frac = m.s ./ m.params.popn\n        inf_force = m.params.β*(transpose(m.params.mixmat)*m.i)\n        n1 = m.numpatch\n        n2 = 2*m.numpatch\n        exp_rate = s_frac.*inf_force      \n        inf_rate = m.params.σ*m.e\n        rec_rate = m.params.γ*m.i\n        ds = -exp_rate\n        de = exp_rate - inf_rate\n        di = inf_rate - rec_rate\n        rates[(n1+1):n2] = ds\n        rates[firstindex(rates):n1] = de\n        rates[(n2+1):lastindex(rates)] = di\n        rates\n    end\nend\n\nevent_rates (generic function with 1 method)\n\n\n\nfunction event_occurred(m::Model, event_ix::Int)\n    ev_type::Int = event_ix  / m.numpatch\n    ev_location::Int = event_ix  / m.numpatch\n    if ev_type == 0 ## exposure\n        m.s[ev_location] -= 1\n        m.e[ev_location] += 1\n    elseif ev_type == 1 ## Infection\n        m.e[ev_location] -= 1\n        m.i[ev_location] += 1\n    elseif ev_type == 2 ## Recovery\n        m.i[ev_location] -= 1\n    end     \nend\n\nevent_occurred (generic function with 1 method)\n\n\n\nusing Match\nusing DataFrames\n\nfunction log_infs(m::Model, x::Vector{Float64}, mixmat::MixMat, week::Int)\n    global Cumulative_infections = DataFrame(\n        Fraction_self = Vector{Real}(),\n        Fraction_CBD = Vector{Real}(),\n        sim = Vector{Int}(),\n        week = Vector{Real}(),\n        name = Vector{String}(),\n        Cumulative_infections = Vector{Int}(),\n        proportion_n = Vector{Int}(),\n        population_n = Vector{Int}()\n    )\n    let n1 = m.numpatch\n        n2 = 2*m.numpatch\n        s = x[firstindex(x):(n1)]\n        e = x[(n1+1):n2]\n        cum_infs = m.params.popn - (s + e) \n        @assert length(cum_infs) == length(mixmat |> names) \"Have $(length(cum_infs)) patches and $(length(mixmat.names)) patch names\"\n        @assert length(cum_infs) == length(m.params.popn) \"Have $(length(cum_infs)) patches and $(length(m.params.popn)) patch names\"\n        frac_self =  @match mixmat.frac_self begin\n            u::Uniform(val) => FracVal\n            v::Variable => 0.0\n        end\n        for ix in cum_infs\n            cum_infs[ix] = cinf\n\n                propn = cinf\n                name = mixmat.names[ix]\n                popn = m.params.popn[ix]\n                sim = 0\n            push!(Cumulative_infections, [frac_self, mixmat.frac_cbd, sim, week, name, cinf, propn, popn])\n        end\n    end\nend\n\nlog_infs (generic function with 1 method)\n\n\n\nfunction accept_simulation(m::Model)::Bool\n    cum_infs = m.params.popn - m.s + m.e\n    cum_infs >= 50000\nend\n\naccept_simulation (generic function with 1 method)\n\n\n\n\n\n\nMoss, R., Naghizade, E., Tomko, M., & Geard, N. (2019). What can urban mobility data reveal about the spatial distribution of infection in a single city? BMC Public Health, 19(1), 656. https://doi.org/10.1186/s12889-019-6968-x"
  }
]