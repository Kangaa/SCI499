{
  "hash": "9a634ec81be4afda80ea4d55c38d79ae",
  "result": {
    "markdown": "# Replicating Moss et al. 2019\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing DrWatson\n@quickactivate \"SCI499\"\n\n#include(readdir(scriptsdir(\"MossModel\"), join = true))\n```\n:::\n\n\n*todo\n\n[@moss2019WhatCanUrban]\n\nThe simulation model is a Rust program comprising five files: Lib.rs, main.rs, mixing.rs, run.rs, seir.rs\nmixing.rs, run.rs, and seir.rs comprise modules for the 'spatial_seir' package defined in lib.rs, which is imported to the main.rs program. \n\n## Mixture Matrix Construction\n\nThe first task is to import the population data which will ultiamtely comprise a mixing matrix. The main components here are an population table (describing the number of individuals in a given SA 3 region) and an origin destination matrix, which specifies how much individuals travel between regions. These two files are composed to a dedictated type 'OdMat' which contains the matrix, population numbers and names of the regions\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nstruct OdMat\n    m::Array{Float64, 2}\n    names::Vector{String}\n    popns::Array{Int, 1}\nend\n```\n:::\n\n\nThe population data for a given set of names is imported by the the funciton \"read_popn\"\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nusing CSV\nusing DataFrames\n\nfunction read_popns(path::AbstractString, names::Vector{String})::Vector{Int}\n    reader = CSV.read(path,DataFrame)\n    popn_tbl = Dict{String, Int}()\n    for row in eachrow(reader)\n        name = row[2]\n        if haskey(popn_tbl, \"$name\")\n            error(\"Multiple populations for $name\")\n        else\n            value = row[3]\n            popn_tbl[\"$name\"] = value\n        end\n    end\n    popns = Vector{Int}()\n    for name in names\n        if haskey(popn_tbl, \"$name\")\n            push!(popns, popn_tbl[\"$name\"])\n        else\n            error(\"No population defined for $name\")\n        end\n    end\n    return popns\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nread_popns (generic function with 1 method)\n```\n:::\n:::\n\n\nodin the data file are found using the find_mm function\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nusing Match\n\nfunction find_mm(path, subdir::Bool)::Vector{String}\n    files = []\n    for entry in readdir(path, join = true)\n        f = entry\n        if f|>isfile\n            ext = split(f, \".\")[2]\n            @match ext begin\n                \"csv\" => push!(files, f)\n            end\n        elseif f|>isdir && subdir\n            for sub_entry in readdir(f, join = true)\n                sub_f = sub_entry\n                if sub_f|>isfile\n                    ext = split(sub_f, \".\")[2]\n                    @match ext begin\n                        \"csv\" => push!(files, sub_f)\n                    end\n                end\n            end\n        end\n    end\n    files|>sort!\n    files\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nfind_mm (generic function with 1 method)\n```\n:::\n:::\n\n\nAnd then imported and combined with population data via 'read_OdMat'\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nfunction read_OdMat(mm_path::AbstractString, popn_path::AbstractString)::OdMat\n    reader = CSV.read(ODdir, DataFrame)\n    names = Vector{String}()\n    values = Vector{Float64}()\n    for row in eachrow(reader)\n        push!(names, string(row[1]))\n        for val in row[2:end]\n            push!(values, val)\n        end\n    end\n    \n    n = length(names)\n    mat = reshape(values, (n, n))\n    popns = read_popns(popn_path, names)\n    \n     OdMat(mat, names, popns)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nread_OdMat (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nODdir = datadir(\"Moss2018\\\\mixing\\\\abs_public.csv\")\npopdir = datadir(\"Moss2018\\\\mixing\\\\sa3-populations.ssv\")\n\nOD = read_OdMat(ODdir, popdir)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nOdMat([0.0 0.0126702534050681 … 0.00829 0.00355; 0.00497014910447313 0.0 … 0.0019 0.00103; … ; 0.000160004800144004 0.000100002000040001 … 0.0 0.00208; 0.000610018300549016 0.000430008600172003 … 0.0169 0.0], [\"20601\", \"20602\", \"20603\", \"20604\", \"20605\", \"20606\", \"20607\", \"20701\", \"20702\", \"20703\"  …  \"21201\", \"21202\", \"21203\", \"21204\", \"21205\", \"21301\", \"21302\", \"21303\", \"21304\", \"21305\"], [91653, 55271, 70367, 148041, 108569, 67798, 94234, 177361, 95593, 107256  …  97790, 137519, 176002, 197453, 184848, 196858, 88342, 87355, 160293, 233138])\n```\n:::\n:::\n\n\nA mixture matrix object (::MixMat)  stores this OD matrix in affition information about the fraction of trips that are taken within individual regions (this can either be a constant across all regions, or vary between regions) and a dedicatied fraction for trips to the cbd (which will be useful for modelling later on).\n\nThe option between constant (::Uniform) or different (::Variable) fractions of self-trips is encoded in its own type hierarchy\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nabstract type FracSelf end\nstruct Uniform{Float64} <: FracSelf \n    a::Float64\nend\nstruct Variable{Array} <: FracSelf end\n```\n:::\n\n\nWhich is an attribute of the MixMat type\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nstruct MixMat\n    m::Array{Real, 2}\n    names::Vector{String}\n    popns::Array{Int, 1}\n    frac_self::FracSelf\n    frac_cbd::Real\nend\n```\n:::\n\n\nBefore actually instantiating this MixMat, there are some checks and scalings to make sure it comes out right (i'm not actually sure what this achieves yet, but I'll keep it in for now.)\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nusing LinearAlgebra\nfunction scale_diag_var!(mat::Matrix{T}, frac_self::Vector{T}) where T<:AbstractFloat\n    @inbounds for i in 1:size(mat, 1)\n        mat[i, :] = mat[i, :] .* ((1.0 - frac_self[i]) ./ sum(mat[i, :]))\n    end\n    diag(mat) .= frac_self\nend\n\nfunction scale_diag_unif!(mat::Matrix{T}, frac_self) where T<:AbstractFloat\n    frac_mix = 1.0 - frac_self\n    @inbounds for i in 1:size(mat, 1)\n        mat[i, :] = mat[i, :] .* (frac_mix ./ sum(mat[i, :]))\n    end\n    diag(mat) .= frac_self\nend\n\nfunction scale_diag!(mat::Matrix{T}, frac_self) where T<:AbstractFloat\n    if isa(frac_self, Uniform)\n        scale_diag_unif!(mat, frac_self.a)\n    elseif isa(frac_self, Variable)\n        scale_diag_var!(mat, frac_self.x)\n    end\nend\n\nfunction test_scale_diag(mat::Matrix{T}, frac_self::T) where T<:AbstractFloat\n    m1 = copy(mat)\n    scale_diag_unif!(m1, frac_self)\n\n    m2 = copy(mat)\n    fs2 = fill(frac_self, size(mat, 1))\n    scale_diag_var!(m2, fs2)\n\n    m3 = copy(mat)\n    fs3 = fill(frac_self, size(mat, 1))\n    fs3[2] *= 0.9\n    scale_diag_var!(m3, fs3)\n\n    @assert all(abs.(1.0 .- sum(m1, dims=2)) .< 1e-8) \"m1 rowsum\"\n    @assert all(abs.(1.0 .- sum(m2, dims=2)) .< 1e-8) \"m2 rowsum\"\n    @assert all(abs.(1.0 .- sum(m3, dims=2)) .< 1e-8) \"m3 rowsum\"\n    @assert m1 == m2 \"mixing matrices differ\"\n    @assert m1 != m3 \"mixing matrices do not differ\"\nend\n\nfunction redistribute!(mat::Matrix{Float64}, popns::Vector{Int},\n    frac_cbd::Float64, cbd_ix::Int)\n    # Determine how much all other regions mix with the CBD.\n    mix_w_cbd = copy(mat[:, cbd_ix])\n    mix_w_cbd[cbd_ix] = 0.0\n\n    # Weight the mixing by each region's resident population.\n    mix_w_cbd .= mix_w_cbd .* Float64.(popns)\n\n    # Normalise these values to conserve the force of infection.\n    mix_w_cbd /= sum(mix_w_cbd)\n\n        for rix in 1:size(mat, 1)\n            if rix == cbd_ix\n                continue\n            end\n\n        row = mat[rix, :]\n        cbd_mix = row[cbd_ix]\n        add_mix = [cbd_mix * (1.0 - frac_cbd) * v for v in mix_w_cbd]\n        row += add_mix\n        row[cbd_ix] = cbd_mix * frac_cbd\n        mat[rix, :] = row\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nredistribute! (generic function with 1 method)\n```\n:::\n:::\n\n\nWith these in place, we can define the constructor for the mixture matrix, taking an OD matrix with fractions of self and cbd mixing as input. \n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nfunction new_MixMat(od::OdMat, frac_self::FracSelf, frac_cbd::Float64)::MixMat\n    mat = copy(od.m)\n    names = copy(od.names)\n    popns = copy(od.popns)\n    scale_diag!(mat, frac_self)\n    cbd_ix = findfirst(isequal(\"20604\"), names)\n    redistribute!(mat, popns, frac_cbd, cbd_ix)\n    MixMat(mat, names, popns, frac_self, frac_cbd)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nnew_MixMat (generic function with 1 method)\n```\n:::\n:::\n\n\nNow we can create our final mixing matrix with OD and some values for frac_self and frac_cbd\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfrac_self = Uniform(0.5)\nfrac_cbd = 0.2\n\nmixmat = new_MixMat(OD, frac_self, frac_cbd)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nMixMat(Real[0.001509960074415217 0.022729530914353313 … 0.015063435697675473 0.008498565379626576; 0.020184561410073135 0.0002905733134707393 … 0.00768857144195623 0.0052909381405588166; … ; 0.003993908953092068 0.002410274797532776 … 0.00010569704882979673 0.048447251137912824; 0.004211899778551643 0.0026433492396756623 … 0.09223036054490781 0.0013466067803184732], [\"20601\", \"20602\", \"20603\", \"20604\", \"20605\", \"20606\", \"20607\", \"20701\", \"20702\", \"20703\"  …  \"21201\", \"21202\", \"21203\", \"21204\", \"21205\", \"21301\", \"21302\", \"21303\", \"21304\", \"21305\"], [91653, 55271, 70367, 148041, 108569, 67798, 94234, 177361, 95593, 107256  …  97790, 137519, 176002, 197453, 184848, 196858, 88342, 87355, 160293, 233138], Uniform{Float64}(0.5), 0.2)\n```\n:::\n:::\n\n\nWe have our mixing matrix (in the ::MixMat type) ready for input into a SEIR Model\n\n## SEIR Model\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nstruct Params\n    β::Float64\n    σ::Float64\n    γ::Float64\n    popn::Vector #Vector of patch sizes\n    mixmat::AbstractArray\nend\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nmutable struct Model\n    params::Params\n    numpatch::Int\n    t::Float64\n    s::Vector\n    e::Vector\n    i::Vector\nend\n```\n:::\n\n\nMake a new model object from parameter set and an initial exposure number\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nfunction new_model(params::Params, e0::Int)\n    #first block selects a random patch from those in the model\n    let \n        n_patch = params.popn |> length\n        rand_choice = rand() |> nextfloat\n        ix = (rand_choice*n_patch) |> trunc\n        @assert ix < n_patch \"Selected patch $ix of $n_patch, from $rand_choice\"\n        s0 = params.popn\n        ##then creates a 'Model' object with the provided parameters\n        m = Model(\n            params = params,\n            n_patch = n_patch,\n            t = 0.0,\n            s = s0,\n            e = zeros(n_patch),\n            i = zeros(n_patch)\n            )\n            ##and sets the number of exposures to e0\n        m.s[ix] -= e0 \n        m.e[ix] += e0 \n        # and returns the model\n        m\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nnew_model (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nfunction event_rates(m::Model)::Array{Float64, 1}\n    let \n        rates = zeros(3*(m.params.popn|> length))\n        s_frac = m.s ./ m.params.popn\n        inf_force = m.params.β*(transpose(m.params.mixmat)*m.i)\n        n1 = m.numpatch\n        n2 = 2*m.numpatch\n        exp_rate = s_frac.*inf_force      \n        inf_rate = m.params.σ*m.e\n        rec_rate = m.params.γ*m.i\n        ds = -exp_rate\n        de = exp_rate - inf_rate\n        di = inf_rate - rec_rate\n        rates[(n1+1):n2] = ds\n        rates[firstindex(rates):n1] = de\n        rates[(n2+1):lastindex(rates)] = di\n        rates\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nevent_rates (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nfunction event_occurred(m::Model, event_ix::Int)\n    ev_type::Int = event_ix  / m.numpatch\n    ev_location::Int = event_ix  / m.numpatch\n    if ev_type == 0 ## exposure\n        m.s[ev_location] -= 1\n        m.e[ev_location] += 1\n    elseif ev_type == 1 ## Infection\n        m.e[ev_location] -= 1\n        m.i[ev_location] += 1\n    elseif ev_type == 2 ## Recovery\n        m.i[ev_location] -= 1\n    end     \nend\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nevent_occurred (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nusing Match\nusing DataFrames\n\nfunction log_infs(m::Model, x::Vector{Float64}, mixmat::MixMat, week::Int)\n    global Cumulative_infections = DataFrame(\n        Fraction_self = Vector{Real}(),\n        Fraction_CBD = Vector{Real}(),\n        sim = Vector{Int}(),\n        week = Vector{Real}(),\n        name = Vector{String}(),\n        Cumulative_infections = Vector{Int}(),\n        proportion_n = Vector{Int}(),\n        population_n = Vector{Int}()\n    )\n    let n1 = m.numpatch\n        n2 = 2*m.numpatch\n        s = x[firstindex(x):(n1)]\n        e = x[(n1+1):n2]\n        cum_infs = m.params.popn - (s + e) \n        @assert length(cum_infs) == length(mixmat |> names) \"Have $(length(cum_infs)) patches and $(length(mixmat.names)) patch names\"\n        @assert length(cum_infs) == length(m.params.popn) \"Have $(length(cum_infs)) patches and $(length(m.params.popn)) patch names\"\n        frac_self =  @match mixmat.frac_self begin\n            u::Uniform(val) => FracVal\n            v::Variable => 0.0\n        end\n        for ix in cum_infs\n            cum_infs[ix] = cinf\n\n                propn = cinf\n                name = mixmat.names[ix]\n                popn = m.params.popn[ix]\n                sim = 0\n            push!(Cumulative_infections, [frac_self, mixmat.frac_cbd, sim, week, name, cinf, propn, popn])\n        end\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nlog_infs (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nfunction accept_simulation(m::Model)::Bool\n    cum_infs = m.params.popn - m.s + m.e\n    cum_infs >= 50000\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\naccept_simulation (generic function with 1 method)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "Moss_files"
    ],
    "filters": [],
    "includes": {}
  }
}